---
description: "統合TDD開発 - init, story, planを1コマンドで完全実行"
argument-hint: "作りたいものを説明してください（例: テトリスゲーム、REST APIサーバー）"
allowed-tools: ["Write", "Read", "LS", "WebSearch", "Bash", "TodoWrite"]
---

# 統合TDD開発

要望: $ARGUMENTS

## 🎯 統合開発フロー

この統合コマンドは以下の機能を順次実行します：
1. **要望分析・技術選択** 
2. **環境初期化** (従来の`/tdd:init`機能)
3. **ユーザーストーリー作成** (従来の`/tdd:story`機能)  
4. **イテレーション計画** (従来の`/tdd:plan`機能)
5. **実装開始案内**

## 指示

以下の5つのPhaseを**順次実行**してください：

---

## 🔍 Phase 1: 要求の本質分析（Requirements Engineering）

### 1.1 5W1H + 制約分析

**ユーザーの真の目的と制約を分析**してください：

**Who（誰が）**: 
- ユーザーの技術レベルを推定してください（初心者/中級者/上級者）
- 想定される使用環境を分析してください（個人/チーム/学習目的）

**What（何を）**: 
- 表面的な要求文の背後にある真のニーズを特定してください
- 「本当に解決したい問題」を見つけてください

**When/Where（いつ・どこで）**:
- 使用タイミング（継続利用/一時利用/学習期間）
- 実行環境の制約（様々なマシン/特定環境/モバイル対応）

**Why（なぜ）**:
- この要求をする根本的な動機を推定してください
- 解決したい課題・得たい価値を特定してください

**How（どのように）**:
- ユーザーが理想とする体験・操作方法を想像してください

**制約分析**:
- 技術的制約（スキル、環境、リソース、権限）
- 時間的制約（開発時間、学習コスト、使用時間）  
- 配布制約（インストール、依存関係、アクセス性、共有方法）

### 1.2 Jobs-to-be-Done分析

**ユーザーが「雇いたい」ジョブを特定**してください：

**メインジョブ**: 
- ユーザーが根本的に達成したいこと
- 解決したい本質的な課題

**関連ジョブ**: 
- 付随的に解決したい課題
- 避けたい作業・トラブル

**感情的ジョブ**: 
- 得たい感情（楽しさ、達成感、安心感）
- 避けたい感情（イライラ、不安、退屈）

**社会的ジョブ**: 
- 他者との関係で得たい価値（共有、評価、貢献）

**競合分析**: 
- 同じジョブを解決する他の手段との差別化ポイント

### 1.3 理想体験からの逆算設計

**摩擦ゼロの体験設計**:

1. **理想体験の定義**: 
   - ユーザーが望む最終的な体験シナリオ
   - 「最高の場合、どうなるか？」

2. **摩擦ポイントの特定**: 
   - 理想体験を阻む障害・面倒な作業
   - 「何が邪魔になるか？」

3. **技術選択の逆算**: 
   - 摩擦を最小化する技術スタック選択
   - 「どうすれば摩擦を除去できるか？」

4. **MVP再定義**: 
   - 理想体験の最小実現版
   - 「最小限で理想体験を実現するには？」

### 1.4 分析結果の統合と技術判定

**分析結果から技術スタックを決定**してください：

上記の分析結果を統合して、最適な技術選択を行ってください：

**体験重視型（摩擦ゼロ重視）**:
- ゼロインストール → 単体HTML/JSファイル
- 即座起動 → サーバーレス実行
- 環境非依存 → ブラウザ標準技術のみ
- 簡単共有 → ファイル一つで完結

**開発効率型（機能重視）**:
- 高機能 → モダンフレームワーク（React, Vue）
- 拡張性 → コンポーネント分割
- 保守性 → 開発サーバー + ビルドツール
- チーム開発 → TypeScript + 品質ツール

**学習・実験型（理解重視）**:
- 透明性 → シンプルな技術スタック（Vanilla JS）
- カスタマイズ性 → 設定可能な構造
- 段階的成長 → 拡張しやすい設計
- 理解促進 → 明確な分離とコメント

**重要な制約**:
- **JavaScriptプロジェクト**: bunまたはpnpmを使用してください。**npmは避けてください**。
- **体験重視**: 外部依存を最小化し、摩擦を除去してください。
- **学習重視**: 複雑すぎず、理解しやすい構造にしてください。

### 1.5 推奨フォルダ構造の提案

**分析結果に基づいて推奨フォルダ構造**を提示してください：

**体験重視型（単体ファイル）**:
```
project/
├── src/
│   ├── game.html           # 最終成果物（全て内包）
│   ├── game.js             # 開発用JavaScript  
│   └── game.css            # 開発用CSS
├── tests/
│   └── game.test.js        # テストファイル
└── package.json            # テスト環境設定のみ
```

**開発効率型（フルスタック）**:
```
project/
├── src/
│   ├── components/         # UI コンポーネント
│   ├── utils/              # 共通ユーティリティ
│   ├── styles/             # スタイルファイル
│   └── main.js             # エントリーポイント
├── tests/
├── dist/                   # ビルド出力
└── vite.config.js          # 開発環境設定
```

**学習型（段階的成長）**:
```
project/
├── step1-basic/            # 基本機能
├── step2-enhanced/         # 機能拡張
├── step3-advanced/         # 高度な機能
├── tests/
└── README.md               # 学習ガイド
```

---

## 🛠️ Phase 2: 要求分析結果に基づく環境構築

### 2.1 分析結果の確認と環境選択

**Phase 1の分析結果を使用**して適切な環境を構築してください：

**分析結果の確認**:
- **体験タイプ**: 体験重視 / 開発効率重視 / 学習重視
- **技術選択**: 単体ファイル / フルスタック / 段階的構造
- **制約条件**: インストール回避 / 拡張性重視 / 理解促進

### 2.2 体験タイプ別の環境構築

**体験重視型の環境構築**:
```bash
# シンプルなディレクトリ構造（外部依存最小）
mkdir -p src tests
# package.json（テスト環境のみ）
cat > package.json << 'EOF'
{
  "name": "standalone-app",
  "version": "1.0.0", 
  "type": "module",
  "scripts": {
    "test": "vitest run",
    "test:watch": "vitest"
  },
  "devDependencies": {
    "vitest": "^1.0.0",
    "jsdom": "^24.0.0"
  }
}
EOF
```

**開発効率型の環境構築**:
```bash
# フルスタック開発環境
mkdir -p src/{components,utils,styles} tests dist
# フレームワーク + 開発ツール環境
```

**学習型の環境構築**:
```bash
# 段階的学習構造
mkdir -p step{1..3}-{basic,enhanced,advanced} tests docs
# 学習ガイド付き環境
```

### 2.3 アジャイル管理ディレクトリの作成

```bash
mkdir -p .claude/agile-artifacts/{stories,iterations,reviews,tdd-logs}
```

### 2.3 .gitignore の設定

個人用ログを除外し、チーム共有価値は含める：

```text
# TDD個人ログ（Git管理対象外）
.claude/agile-artifacts/tdd-logs/

# 一般的な除外項目
node_modules/
__pycache__/
.env
.DS_Store
```

### 2.4 Git リポジトリの初期化（必要な場合）

```bash
git init
git add .gitignore
git commit -m "[INIT] TDD environment setup with agile structure"
```

### 2.5 基本テスト環境の確認

プロジェクトタイプに応じてテストコマンドを確認：

**JavaScript/TypeScript**:
```bash
# パッケージマネージャーの確認とテストスクリプト確認
if command -v bun &> /dev/null; then
  echo "推奨: bun を使用"
elif command -v pnpm &> /dev/null; then
  echo "推奨: pnpm を使用"
else
  echo "推奨: bun または pnpm のインストールを検討"
fi
```

**Python**:
```bash
# テストフレームワークの確認
python -c "import pytest" 2>/dev/null && echo "pytest 利用可能" || echo "pytest インストール推奨"
```

---

## 📋 Phase 3: 要求分析結果に基づくストーリー作成

### 3.1 Jobs-to-be-Done からストーリーへの変換

**Phase 1で特定したJobsをストーリーに変換**してください：

**メインジョブ → Story 1 (MVP)**:
- ユーザーの根本的な目的を達成する最小機能
- Phase 1で特定した「理想体験」の最小実現版

**関連ジョブ → Story 2-3 (Core)**:
- 摩擦を除去し、体験を向上させる機能
- ユーザーが避けたい作業・トラブルを解決

**感情的・社会的ジョブ → Story 4+ (Enhancement)**:
- 楽しさ、達成感、安心感を提供する機能
- 共有、評価、貢献の価値を実現する機能

### 3.2 体験中心のMVP定義

**従来のシステム中心思考**:
❌ 「ゲームボードが表示される」（システムの機能）

**要求分析に基づく体験中心思考**:
✅ 「ファイルをダブルクリックして即座にゲームを楽しめる」（ユーザーの体験）

**体験中心MVP定義の手順**:
1. **理想体験シナリオ**: Phase 1で定義した理想体験を使用
2. **摩擦ポイント除去**: 最大の障害となる摩擦を除去する機能
3. **価値実現確認**: メインジョブが達成できる最小限の機能
4. **MVP境界決定**: 「これがあれば価値を実感できる」境界線

### 3.3 要求分析結果の統合

**Phase 1の分析結果を活用**してストーリーを具体化：

**5W1H分析結果の活用**:
- Who → ユーザータイプの明確化
- What → 機能要求の具体化  
- When/Where → 使用コンテキストの反映
- Why → 価値・理由の明確化
- How → 操作方法・体験の設計

**制約分析結果の反映**:
- 技術制約 → 実装可能性の考慮
- 時間制約 → 優先度・工数の調整
- 配布制約 → アクセス方法・共有方法の設計

### 3.3 受け入れ基準の定義

各ストーリーに具体的な**受け入れ基準 (Acceptance Criteria)**を定義：

```
GIVEN [前提条件]
WHEN [実行操作]  
THEN [期待結果]
```

### 3.4 ストーリーファイルの作成

`.claude/agile-artifacts/stories/` ディレクトリに以下の形式でファイルを作成：

**ファイル名**: `user-stories-v1.0.md`

**テンプレート**:
```markdown
# ユーザーストーリー v1.0

**プロジェクト**: [要望名]
**作成日**: [今日の日付]
**技術スタック**: [選択した技術]

## Story 1: MVP - [簡潔な機能名]

**ストーリー**:
As a [ユーザー]
I want [機能]
So that [価値]

**受け入れ基準**:
- [ ] GIVEN [前提] WHEN [操作] THEN [結果]
- [ ] [追加の基準...]

**優先度**: 🔥 CRITICAL (MVP)
**工数見積**: [時間]

## Story 2: Core - [機能名]
[同様の形式...]

## Story 3: Core - [機能名] 
[同様の形式...]
```

---

## 📅 Phase 4: イテレーション計画 (plan統合)

### 4.1 Kent Beck "90分ルール" の適用

**短期集中の90分イテレーション**で実装計画を作成：

1. **90分で達成可能な最小機能**を特定
2. **Red-Green-Refactorサイクル**を3-5回実行
3. **動作確認とコミット**まで完了

### 4.2 実装順序の決定

**MVPファースト原則**で実装順序を決定：

**Iteration 1 (90分)**: Story 1のMVP実装
- Task 1.1: 失敗するテスト作成 (Red)
- Task 1.2: 最小実装 (Green)  
- Task 1.3: リファクタリング (Refactor)
- Task 1.4: 動作確認・コミット

### 4.3 Kent Beck三大戦略の適用計画

各Task実装時の戦略を事前に計画：

**Fake It戦略** (60%以上で使用):
- 実装方法が不明確
- 複雑なビジネスロジック
- まずはハードコーディングで動かす

**Triangulation戦略**:
- 2つ目のテストで一般化
- パターンが見えてきた時

**Obvious Implementation戦略**:
- 数学的に自明な処理のみ
- 1行で完結する簡単な処理

### 4.4 技術的制約・リスクの洗い出し

**技術リスク**:
- 未経験の技術スタック
- パフォーマンス要件
- 外部API依存

**対応策**:
- スパイクソリューション（調査用実装）
- 代替手段の準備
- 段階的複雑化

### 4.5 イテレーション計画ファイルの作成

`.claude/agile-artifacts/iterations/` ディレクトリに以下を作成：

**ファイル名**: `iteration-plan-v1.0.md`

**テンプレート**:
```markdown
# イテレーション計画 v1.0

**プロジェクト**: [要望名]
**計画日**: [今日の日付]
**イテレーション期間**: 90分

## Iteration 1: MVP実装

**目標**: Story 1の完全実装

**Task分解**:
### Task 1.1: [機能名] テスト作成 (Red) - 15分
- [ ] 失敗するテストの作成
- [ ] テスト実行で Red 確認
- [ ] コミット: [BEHAVIOR] Add failing test for [機能名]

### Task 1.2: [機能名] 最小実装 (Green) - 20分  
- [ ] [戦略名] 戦略で最小実装
- [ ] テスト実行で Green 確認
- [ ] コミット: [BEHAVIOR] Implement [機能名] with [戦略名]

### Task 1.3: [機能名] リファクタリング (Refactor) - 15分
- [ ] 構造改善・命名改善
- [ ] 全テスト Green 確認
- [ ] コミット: [STRUCTURE] Refactor [機能名] for clarity

### Task 1.4: 動作確認・統合 - 15分
- [ ] 実際の動作確認
- [ ] ユーザー目線での価値確認
- [ ] README更新（実行方法）

**成功基準**:
- [ ] 全テスト通過
- [ ] 実際に動作確認できる
- [ ] ユーザーが価値を実感できる

**次のイテレーション候補**:
- Story 2: [次の機能名]
- Story 1の改善・拡張
```

---

## 🚀 Phase 5: 実装開始案内

### 5.1 開発環境の最終確認

**実装開始前チェックリスト**:
- [ ] Git リポジトリが初期化されている
- [ ] テスト環境が構築されている  
- [ ] ユーザーストーリーが作成されている
- [ ] 90分イテレーション計画が完成している
- [ ] 実装戦略が決定されている

### 5.2 TDD開始コマンドの案内

**Kent Beck純正TDD**で実装を開始してください：

```bash
# 具体的機能の実装開始
/tdd:run [Story 1の機能名]

# 例:
/tdd:run display-block  # テトリスブロック表示
/tdd:run add-numbers    # 計算機の加算機能
/tdd:run health-check   # APIのヘルスチェック
```

### 5.3 品質ゲート設定の確認

各実装後に必ず以下を実行：

```bash
# テスト実行
[パッケージマネージャー] test -- --watchAll=false --forceExit

# 品質チェック  
[パッケージマネージャー] run lint
[パッケージマネージャー] run typecheck  # TypeScriptの場合

# 動作確認
[パッケージマネージャー] run dev
```

### 5.4 継続的フィードバックループの設定

**各機能完成後の確認手順**:

1. **動作デモ**: 実際にユーザーが使える状態か？
2. **価値確認**: ユーザーにとって価値があるか？
3. **次の優先度**: 次に重要な機能は何か？
4. **改善点**: 現在の実装で改善すべき点は？

### 5.5 完了メッセージの表示

```text
🎉 統合TDD開発環境の構築完了！

📋 作成された成果物:
├── .claude/agile-artifacts/
│   ├── stories/user-stories-v1.0.md     # ユーザーストーリー
│   ├── iterations/iteration-plan-v1.0.md # イテレーション計画
│   └── [その他のディレクトリ]

🎯 プロジェクト概要:
- **要望**: $ARGUMENTS
- **技術スタック**: [選択した技術]
- **MVPストーリー**: [Story 1の内容]
- **初回イテレーション**: 90分でMVP実装

🚀 実装開始準備完了:

Kent Beck純正TDDで実装開始:
/tdd:run [Story 1の機能名]

プロジェクト状況確認:
/tdd:status

品質レビュー実施:
/tdd:review

💡 TDD原則の実践:
1. Red → Green → Refactor サイクル厳守
2. 失敗するテストから必ず開始
3. 最小実装で Green を達成
4. 振る舞いを変えずに構造改善

🎯 成功の鍵:
- テストファースト厳守
- 90分集中イテレーション
- 継続的フィードバック
- アジャイル価値の実現
```

## 完了条件

**Phase 1**: 
- ✅ 要望分析完了・技術スタック決定
- ✅ 推奨フォルダ構造提示

**Phase 2**:
- ✅ .claude/agile-artifacts/ 構造が作成されている
- ✅ .gitignore が適切に設定されている  
- ✅ Git リポジトリが初期化されている（必要な場合）
- ✅ テスト環境の状態が確認されている

**Phase 3**:
- ✅ MVPファーストのユーザーストーリーが作成されている
- ✅ 受け入れ基準が具体的に定義されている
- ✅ stories/ ディレクトリにファイルが保存されている

**Phase 4**:
- ✅ 90分イテレーション計画が作成されている
- ✅ Kent Beck戦略の適用計画が完成している
- ✅ iterations/ ディレクトリにファイルが保存されている

**Phase 5**:
- ✅ 実装開始コマンドが明確に案内されている
- ✅ 品質ゲートが設定されている
- ✅ 継続的フィードバックループが確立されている

## エラーハンドリング

**Phase 1 失敗**: 要望不明確・技術スタック判定不可
→ 詳細な要望確認を依頼

**Phase 2 失敗**: Git初期化失敗・既存プロジェクト衝突  
→ 既存状況確認・競合解決案提示

**Phase 3 失敗**: ユーザーストーリー作成失敗・入力値不正
→ ストーリー形式の再説明・要望の再整理

**Phase 4 失敗**: イテレーション計画作成失敗・工数見積もり異常
→ より小さな単位での計画作成・リスク要因の特定

**Phase 5 失敗**: 最終案内表示失敗
→ 前段階の結果確認・部分的成功要素の保護