---
description: "TDD実行環境。Red→Green→Refactorサイクルを実行し、必須ゲートを通過させながら開発を進めます。"
argument-hint: "実行オプション（--step|--micro|--step X.Y|--resume）"
allowed-tools: ["Bash", "Read", "Write", "TodoWrite"]
---

# TDD実行

オプション: $ARGUMENTS（--step, --micro, --step X.Y, --resume）

## 実行モード

### デフォルト: イテレーション全体の連続実行 🎯

オプションなしの場合、現在のイテレーションの全ステップを自動実行。

### オプション

- `--step`: 単一ステップのみ実行して終了
- `--micro`: ステップごとに確認しながら実行
- `--step X.Y`: 特定ステップから開始
- `--resume`: 中断箇所から再開

## 実行フロー

### 1. プロジェクトコンテキストの検出

**プロジェクトコンテキスト検出手順**：

Bashツールで以下を実行：

1. **言語検出ロジック読み込み**：
   `source ~/.claude/commands/shared/language-detector.md`

2. **コンテキスト情報取得**：
   - `get_current_context`関数でコンテキスト取得
   - ディレクトリと言語を分離抽出
   - コンテキスト情報を表示

3. **プラクティスファイル決定**：
   - **混合プロジェクトの場合**：
     - `get_mixed_languages`で言語リスト取得
     - `get_primary_language`でプライマリ言語決定
     - 混合プロジェクト情報を表示
   - **単一言語プロジェクトの場合**：
     - `resolve_practice_file`でプラクティスファイル取得
     - 適用プラクティス情報を表示

### 2. 準備

- 最新のイテレーションファイルを読み込み
- 前回フィードバックの確認（未収集なら警告）
- 言語別コマンドの準備

### 3. 言語別コマンドの準備

**言語別コマンド抽出手順**：

Bashツールで以下を実行：

### 1. コマンド抽出関数定義

**関数名**: `extract_commands`
**機能**: プラクティスファイルから特定コマンドタイプを抽出
**抽出コマンド**: `grep "^$command_type:" "$practice_file" | cut -d'"' -f2`

### 2. 各種コマンドの取得

- **TEST_CMD**: テストコマンドを抽出
- **LINT_CMD**: リントコマンドを抽出
- **BUILD_CMD**: ビルドコマンドを抽出
- **RUN_CMD**: 実行コマンドを抽出
- **START_CMD**: スタートコマンドを抽出
- **DEV_CMD**: 開発コマンドを抽出

### 3. フォールバック設定

- テストコマンド未設定時：エラーメッセージ表示
- リントコマンド未設定時：エラーメッセージ表示

### 4. サーバーコマンド優先度決定

**優先度順**: DEV_CMD > START_CMD > RUN_CMD

- 最初に見つかったコマンドをSERVER_CMDに設定

### 5. コマンド情報表示

- 必須コマンド：テスト、リント
- オプションコマンド：ビルド、サーバー（バックグラウンド実行指定）

### 4. 実行モードに応じた処理

#### イテレーション全体実行（デフォルト）

```text
🚀 イテレーション N 連続実行を開始します
────────────────────────────────────────
  📋 総ステップ数: X個
  ⏱️ 推定時間: XX分
  🎯 自動実行モード
────────────────────────────────────────

各ステップを自動的に実行していきます...
```

#### 単一ステップ実行（--step）

```text
🔄 単一ステップモードで実行します
次の未完了ステップのみを実行して終了します。
```

### 5. 各ステップの実行

#### 🔴 RED（テスト作成）

Kent Beck 視点で最小限のテストを作成。**REDフェーズ強制化**: テスト失敗確認まで次に進めません。
Kent Beck原則の詳細は @~/.claude/commands/shared/kent-beck-principles.md を参照

**REDフェーズ実行手順**：

Bashツールを使用して以下を順次実行：

1. **REDフェーズ開始**：

   ```
   echo "🔴 RED フェーズ: 失敗するテストの作成"
   ```

2. **作業ディレクトリ移動**（必要時）：
   - `$CONTEXT_DIR`が"."でない場合は`cd "$CONTEXT_DIR"`実行

3. **実装前テスト実行**：
   - 警告メッセージ表示：`echo "⚠️ 実装前のテスト実行（失敗することを確認）"`
   - テストコマンド表示：`echo "🧪 テスト実行: $TEST_CMD"`
   - テスト実行：`eval "$TEST_CMD"`
   - 終了コードを記録

4. **テスト結果の詳細表示**：
   - 出力の最初30行を表示
   - 終了コードを表示

5. **REDフェーズ必須条件チェック**：
   - **終了コード = 0の場合**：
     - エラーメッセージ表示："❌ 致命的エラー: テストが通ってしまいました！"
     - TDD原則違反の説明表示
     - 対処方法を表示（実装コード削除/コメントアウト等）
     - プロセス終了（exit 1）
   - **終了コード ≠ 0の場合**：
     - 成功メッセージ表示："✅ REDフェーズ成功: テストが期待通り失敗しました"
     - 失敗理由を抽出・表示
     - **ファイル同期実行**: ストーリーファイルとイテレーションファイルの進捗を更新
     - 次フェーズへの進行メッセージ表示

#### 🟢 GREEN（最小実装）

**Fake It戦略必須**: 最初はハードコーディング。**GREENフェーズ強制化**: テスト成功確認後のみ次へ進行。

**GREENフェーズ実行手順**：

Bashツールを使用して以下を順次実行：

1. **GREENフェーズ開始**：

   ```
   echo "🟢 GREEN フェーズ: 最小実装でテストを通す"
   echo "💡 Fake It戦略: まずはハードコーディングで実装"
   ```

2. **実装後テスト実行**：
   - テストコマンド表示：`echo "🧪 実装後テスト実行: $TEST_CMD"`
   - テスト実行：`eval "$TEST_CMD"`
   - 終了コードを記録

3. **テスト結果の詳細表示**：
   - 出力の最初30行を表示
   - 終了コードを表示

4. **GREENフェーズ必須条件チェック**：
   - **終了コード = 0の場合**：
     - 成功メッセージ表示："✅ GREENフェーズ成功: テストが通りました"
     - **必須ゲート: コード品質チェック**
       - リントコマンド表示：`echo "🧹 リント実行: $LINT_CMD"`
       - リント実行：`eval "$LINT_CMD"`
       - リント結果チェック：
         - 失敗時：エラー表示とプロセス終了
         - 成功時：品質OK表示、**ファイル同期実行**、次フェーズへ
   - **終了コード ≠ 0の場合**：
     - エラーメッセージ表示："❌ GREENフェーズ失敗: テストがまだ失敗しています"
     - 失敗理由を抽出・表示
     - 修正指示とプロセス終了

コミット:

**GREENフェーズコミット**：
Bashツールで以下を実行（コミット規則は @~/.claude/commands/shared/commit-rules.md を参照）：

```
git add .
git commit -m "[BEHAVIOR] Step X.Y: Fake It implementation"
```

#### 🔵 REFACTOR（必要時）

**構造的変更のみ**: 振る舞いは変えない。**REFACTORフェーズ強制化**: リファクタリング実行とテスト確認。
2つ目のテストでTriangulation戦略を検討（@~/.claude/commands/shared/kent-beck-principles.md 参照）

**REFACTORフェーズ実行手順**：

Bashツールを使用して以下を順次実行：

1. **REFACTORフェーズ開始**：

   ```
   echo "🔵 REFACTOR フェーズ: 構造的改善（振る舞いは変更しない）"
   echo "⚠️ 重要: 機能追加ではなく、コードの構造のみを改善"
   ```

2. **リファクタ前のテスト状態記録**：
   - 状態記録メッセージ表示：`echo "📸 リファクタ前のテスト状態を記録"`
   - テスト実行：`eval "$TEST_CMD"`
   - 終了コードチェック：
     - 非0の場合：エラー表示とプロセス終了（成功状態からのみ開始可能）
     - 0の場合：成功状態確認済み表示

3. **リファクタリング実行指示**：
   リファクタリングを実行してください（構造的変更のみ）

4. **リファクタ後の動作保証確認**：
   - テストコマンド表示：`echo "🧪 リファクタ後の動作保証確認: $TEST_CMD"`
   - テスト実行：`eval "$TEST_CMD"`
   - 終了コードを記録

5. **テスト結果の詳細表示**：
   - 出力の最初30行を表示
   - 終了コードを表示

6. **REFACTORフェーズ必須条件チェック**：
   - **終了コード = 0の場合**：
     - 成功メッセージ表示："✅ REFACTORフェーズ成功: 振る舞いが保持されています"
     - **必須ゲート: コード品質向上確認**
       - リントコマンド表示：`echo "🧹 リント実行: $LINT_CMD"`
       - リント実行：`eval "$LINT_CMD"`
       - リント結果チェック：
         - 失敗時：品質悪化エラー表示とプロセス終了
         - 成功時：品質維持確認、**ファイル同期実行**、フェーズ完了表示
   - **終了コード ≠ 0の場合**：
     - エラーメッセージ表示："❌ 致命的エラー: リファクタで動作が破壊されました"
     - 対処方法を表示（変更を元に戻す等）
     - プロセス終了

7. **リファクタ成功時のコミット**（コミット規則は @~/.claude/commands/shared/commit-rules.md を参照）：

   ```
   git add .
   git commit -m "[STRUCTURE] Step X.Y: Refactor for better structure"
   ```

### 4. 必須チェック（各ステップ後）

参照: @~/.claude/commands/shared/mandatory-gates.md

- **動作確認**: プロジェクトタイプに応じて実施
  - Web: サーバーバックグラウンド起動 + Playwright MCP でスクリーンショット
  - CLI: コマンド実行結果
  - API: サーバーバックグラウンド起動 + curl でレスポンス確認

**サーバーバックグラウンド実行手順**：

Bashツールで以下の関数を実装・実行：

### 1. サーバー起動機能

**プロジェクトタイプ判定**：

- Web/APIプロジェクトの場合のみサーバー起動
- CLIプロジェクトはサーバー不要

**サーバー起動慣列**：

1. 起動メッセージ表示：`echo "🚀 サーバーバックグラウンド起動中..."`
2. コマンド表示：`echo "📝 コマンド: $SERVER_CMD"`
3. バックグラウンド実行：`nohup bash -c "$SERVER_CMD" > server.log 2>&1 &`
4. PID記録：SERVER_PID変数に保存
5. 情報表示：PIDとログファイルの表示
6. 起動待機：3秒待機
7. プロセス確認：`kill -0 "$SERVER_PID"`で生存確認
8. 成功時：ポート検出実行
9. 失敗時：エラーログ表示

### 2. ポート検出機能

**一般的ポートチェック**：

- ポートリスト：3000, 8000, 8080, 5000, 4000, 9000
- チェックコマンド：`netstat -tuln | grep ":$port "`
- 発見時：URL表示と環境変数設定

**ログファイルから検索**：

- キーワード："port", "listen"
- 抽出コマンド：`grep -i "port\|listen" server.log | grep -o "[0-9]\{4,5\}"`

### 3. サーバー停止機能

**停止慣列**：

1. PID生存確認：`kill -0 "$SERVER_PID"`
2. 停止メッセージ表示
3. 通常停止：`kill "$SERVER_PID"`
4. 待機：2秒待機
5. 強制停止（必要時）：`kill -9 "$SERVER_PID"`
6. 完了メッセージ表示

- **受け入れ基準**: ストーリーファイルを更新

**ファイル完全同期機能**：

Bashツールで以下の機能を実装・実行：

### ストーリー・イテレーション同期関数

**基本パラメータ**：

- `current_step`: 現在のステップ（例："1.2"）
- `phase`: フェーズ名（RED/GREEN/REFACTOR）

**Step情報解析**：

- ストーリーID抽出：`echo "$current_step" | sed 's/\([0-9]\+\)\..*/\1/'`
- イテレーション番号：ストーリーIDと同じ値を使用

### 1. ストーリーファイル更新機能

**対象ファイル**：`.claude/agile-artifacts/stories/project-stories.md`

**更新コマンド**：

```
sed -i "/\*\*Story.*$story/,/^\*\*Story\|^$/s/- \[ \] .*${criteria}/- \[x\] ${criteria}/" "$story_file"
```

**フェーズ別更新内容**：

- RED: "テスト失敗確認"
- GREEN: "実装完了", "テスト成功"  
- REFACTOR: "リファクタリング完了"

### 2. イテレーションファイル更新機能

**対象ファイル**：`.claude/agile-artifacts/iterations/iteration-${iteration}.md`

**ステップ進捗更新**：

```
sed -i "/Step.*$step/,/^###\|^$/s/- \[ \]/- \[x\]/g" "$iteration_file"
```

### 3. 必須ゲート更新機能

**必須ゲート更新**：
```
sed -i "/## 必須ゲート/,/^##\|^$/s/- \[ \] \*\*${gate_type}\*/- \[x\] **${gate_type}**/" "$iteration_file"
```

**フェーズ別ゲート**：
- RED: "動作確認"
- GREEN: "受け入れ基準"
- REFACTOR: "Gitコミット"

**同期完了メッセージ**：各更新後に成功・失敗メッセージを表示

- **進捗更新**: イテレーションファイルの必須ゲート更新

**進捗更新実行方法**：

各フェーズ完了時にBashツールで以下を実行：

### REDフェーズ完了時
```bash
# ストーリーファイル更新
sed -i "/\*\*Story.*$story_id/,/^\*\*Story\|^$/s/- \[ \] .*テスト失敗確認/- \[x\] テスト失敗確認/" .claude/agile-artifacts/stories/project-stories.md

# イテレーションファイル更新
sed -i "/Step.*$current_step/,/^###\|^$/s/- \[ \] RED:/- \[x\] RED:/" .claude/agile-artifacts/iterations/iteration-*.md
echo "📝 REDフェーズ進捗を更新しました"
```

### GREENフェーズ完了時
```bash
# ストーリーファイル更新
sed -i "/\*\*Story.*$story_id/,/^\*\*Story\|^$/s/- \[ \] .*実装完了/- \[x\] 実装完了/" .claude/agile-artifacts/stories/project-stories.md
sed -i "/\*\*Story.*$story_id/,/^\*\*Story\|^$/s/- \[ \] .*テスト成功/- \[x\] テスト成功/" .claude/agile-artifacts/stories/project-stories.md

# イテレーションファイル更新
sed -i "/Step.*$current_step/,/^###\|^$/s/- \[ \] GREEN:/- \[x\] GREEN:/" .claude/agile-artifacts/iterations/iteration-*.md
echo "📝 GREENフェーズ進捗を更新しました"
```

### REFACTORフェーズ完了時
```bash
# ストーリーファイル更新
sed -i "/\*\*Story.*$story_id/,/^\*\*Story\|^$/s/- \[ \] .*リファクタリング完了/- \[x\] リファクタリング完了/" .claude/agile-artifacts/stories/project-stories.md

# イテレーションファイル更新
sed -i "/Step.*$current_step/,/^###\|^$/s/- \[ \] REFACTOR:/- \[x\] REFACTOR:/" .claude/agile-artifacts/iterations/iteration-*.md
echo "📝 REFACTORフェーズ進捗を更新しました"
```

### 5. 完了確認と継続判定

各ステップ完了後、完全な確認と同期を実行：

**完全確認機能（強化版）**：

Bashツールで以下の厳格な確認機能を実装・実行：

### 基本確認手順

**確認開始メッセージ**：
```
echo "🔍 完了確認開始: Step $current_step ($phase フェーズ)"
echo "────────────────────────────────────────"
```

**ファイルパス設定**：
- ストーリーファイル：`.claude/agile-artifacts/stories/project-stories.md`
- イテレーションファイル：`.claude/agile-artifacts/iterations/iteration-${iteration_num}.md`

### 1. ストーリー完了確認（強化版）

**ファイル存在確認**：
- ファイルが存在しない場合：致命的エラーとしてプロセス終了

**未完了数カウント**：
```
grep -A 15 "\*\*Story.*$story_id" "$story_file" | grep -c "- \[ \]"
```

**未完了項目がある場合**：
- 未完了数を表示
- 未完了項目リストを表示（最大5個）
- 進行停止メッセージとプロセス終了

**全完了の場合**：
- 成功メッセージ表示

### 2. イテレーション完了確認（強化版）

**ステップ完了確認**：
```
grep -A 5 "Step.*$current_step" "$iteration_file" | grep -c "- \[ \]"
```

**必須ゲート確認**：
```
grep -A 20 "## 必須ゲート" "$iteration_file" | grep -c "- \[ \]"
```

**未完了がある場合**：
- 未完了ゲートリストを表示（最大3個）
- レビュー進行停止メッセージとプロセス終了

### 3. 総合判定

**両方の確認結果を統合**：
- ストーリー確認 AND イテレーション確認の両方が成功
- 成功時：次フェーズ進行許可メッセージ
- 失敗時：TDD原則違反としてプロセス終了

**各フェーズ後に必須実行**：確認なしでの進行は禁止

### 6. モードに応じた完了処理

#### イテレーション完了時（デフォルト）

全ステップ・全必須ゲート完了後、フィードバック収集を実行。

#### 単一ステップ完了時（--step）

```text
✅ Step X.Y 完了
次のステップを実行するには: /tdd:run --step
```

### 6. フィードバック収集（イテレーション完了時のみ）

#### 完了時選択肢の表示

イテレーション完了後、以下の選択肢を表示：

```text
🎉 イテレーション N 完了！

次の開発段階を選択してください：

1. 継続開発 🚀
   /tdd:plan N+1
   次のイテレーションを自動計画

2. 機能追加 ➕
   追加機能を分析して自動計画

3. フィードバック入力 💭
   詳細なフィードバックを提供

4. 品質改善 🔧
   現在のコード品質向上

5. 完了 ✅
   現在の状態でプロジェクト終了

数字でお答えください: [1-5]
```

#### 選択肢3: フィードバック入力の詳細処理

**Step 1: 満足度確認**

```text
💭 詳細フィードバック収集

まず最初にお聞きします：

**今回のイテレーションは期待通りでしたか？**

1⭐ 全く期待外れ
2⭐ やや期待外れ  
3⭐ 普通
4⭐ やや期待以上
5⭐ 大変満足

数字でお答えください: [1-5]
```

**回答受信後、詳細コメントを収集**

```text
ありがとうございます。

**その理由を一言で教えてください：**
（良かった点・不満な点など）
```

**Step 2: 次の要望確認**

```text
次にお聞きします：

**次に欲しい機能や改善は何ですか？**

一番優先したいもの1つを教えてください。
```

**Step 3: プロセス改善確認**

```text
最後にお聞きします：

**開発プロセスで改善したい点はありますか？**

なければ「なし」とお答えください。
```

#### フィードバック収集完了後の継続フロー

フィードバック収集完了後、必ず以下を表示：

```text
✅ フィードバックを記録しました。

🚀 次のステップを選択してください：

1. 継続開発 🚀
   /tdd:plan N+1
   次のイテレーションを自動計画

2. 機能追加 ➕
   追加機能を分析して自動計画

3. 品質改善 🔧
   現在のコード品質向上

4. レビュー確認 📊
   /tdd:review N
   詳細な品質分析結果を確認

5. 完了 ✅
   現在の状態でプロジェクト終了

数字でお答えください: [1-5]
```

#### 選択肢4: 品質改善の詳細処理

選択肢4（品質改善）が選択された場合の処理：

```text
🔧 コード品質改善を実行します

以下の改善を実施：
- テスト環境の最適化
- テストカバレッジの向上  
- コード構造の改善
- 依存関係の整理

改善完了後、再度次ステップ選択肢を表示します。
```

**品質改善完了後も必ず継続フロー選択肢を再表示**

### 7. フィードバック保存

`.claude/agile-artifacts/reviews/iteration-N-feedback.md`:

**フィードバック保存コミット**：
BashツールでフィードバックファイルをGitコミット（コミット規則は @~/.claude/commands/shared/commit-rules.md を参照）：
```
git commit -m "[BEHAVIOR] Save iteration N feedback"
```

## エラー対応

参照: `~/.claude/commands/shared/error-handling.md`

エラー時は 3 つの質問に答えてから対応。

## プロジェクトタイプ別確認

参照: `~/.claude/commands/shared/project-verification.md`

### サーバーバックグラウンド実行の使用例

**プロジェクトタイプ別動作確認手順**：

Bashツールでプロジェクトタイプを判定し、適切な確認を実行：

### Webプロジェクトの場合
1. サーバーバックグラウンド起動関数呼び出し
2. ポート検出成功時：Playwright MCPでスクリーンショット取得
3. 確認完了後：サーバー停止関数呼び出し

### APIプロジェクトの場合
1. サーバーバックグラウンド起動関数呼び出し
2. ポート検出成功時：curlでAPIレスポンス確認
   - Healthチェック：`curl -s "http://localhost:$DETECTED_SERVER_PORT/health"`
   - APIチェック：`curl -s "http://localhost:$DETECTED_SERVER_PORT/api"`
3. 確認完了後：サーバー停止関数呼び出し

### CLIプロジェクトの場合
- サーバー不要：コマンド実行結果のみ確認

## 完了メッセージ

### イテレーション完了時

```text
🎉 イテレーション N 完了！
技術実装: 100%

次の開発段階を選択してください：

1. 継続開発 🚀
   /tdd:plan N+1
   次のイテレーションを自動計画

2. 機能追加 ➕
   追加機能を分析して自動計画

3. フィードバック入力 💭
   詳細なフィードバックを提供

4. 品質改善 🔧
   現在のコード品質向上

5. 完了 ✅
   現在の状態でプロジェクト終了

数字でお答えください: [1-5]
```

### 単一ステップ完了時

```text
✅ Step X.Y 完了！
進捗: X/Y ステップ完了

続行: /tdd:run （イテレーション全体）
     /tdd:run --step （次のステップのみ）
```

### 各選択肢実行完了後の継続フロー

どの選択肢を実行した場合でも、処理完了後に必ず以下の継続選択肢を表示：

```text
🚀 次のステップを選択してください：

1. 継続開発 🚀
   /tdd:plan N+1
   次のイテレーションを自動計画

2. 機能追加 ➕
   追加機能を分析して自動計画

3. フィードバック入力 💭（再度可能）
   追加のフィードバックを提供

4. 品質改善 🔧（再度可能）
   さらなるコード品質向上

5. レビュー確認 📊
   /tdd:review N
   詳細な品質分析結果を確認

6. 完了 ✅
   現在の状態でプロジェクト終了

数字でお答えください: [1-6]
```

**重要**: ユーザーが迷わないよう、どの処理完了後も必ず継続フロー選択肢を表示すること
