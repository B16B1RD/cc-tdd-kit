# TDD特化認知強化プロトコル

## 🧠 TDD実行時の特別認知強化

### 日付取得の実践例

#### Web検索時の正しい手順
```bash
# 1. 現在年を取得
CURRENT_YEAR=$(date +%Y)
# 2. 検索クエリに現在年を使用
search_query="tetris specifications ${CURRENT_YEAR}"
```

#### CHANGELOG更新時の日付確認
```bash
# 新規エントリ追加時
TODAY=$(date +"%Y-%m-%d")
echo "## [0.2.1] - ${TODAY}"
```

### Kent Beck原則適用時の論理検証

#### Red → Green → Refactor サイクル検証
- **Red段階**: テストが本当に失敗するか論理的に確認
- **Green段階**: 最小実装で本当にテストがパスするか検証  
- **Refactor段階**: 振る舞いを変えずに構造のみ変更したか確認

#### Fake It戦略の論理的適用
1. 最初は恥ずかしいくらいシンプルに実装（ハードコーディング）
2. 2つ目のテストで一般化の必要性を論理的に判断
3. Triangulation で適切な抽象化レベルを決定

### バージョン・日付の厳格確認

#### リリース管理での日付検証
- **現在日時**: `date +"%Y-%m-%d"` で能動的に取得した日付で確認
- **新規CHANGELOGエントリ**: 追加時に `date` コマンドの結果と一致しているか確認
- **既存日付**: 未来の日付になっていないか（`date`で取得した現在日時以前か）検証
- **Git タグとCHANGELOG**: 対応するエントリ同士の日付が一致しているか検証
- Bashコマンドによる能動的な日付取得を徹底し、受動的な環境情報に依存しない

#### バージョニング論理チェック
- Semantic Versioning の適用が論理的に正しいか確認
- MAJOR.MINOR.PATCH の変更理由が明確か検証

### 実装前後の段階的検証

#### 実装前チェックリスト
1. **前提条件の明確化**: 何を実装しようとしているか
2. **受け入れ基準の確認**: どうなれば成功か
3. **既存コードへの影響**: 何が壊れる可能性があるか

#### 実装後検証プロトコル
1. **動作確認**: 期待通りに動くか
2. **テスト確認**: 全テストがパスするか
3. **コード品質**: リント・型チェックが通るか
4. **Git状態確認**: コミットが適切に分離されているか

### エラー発生時の論理的対応

#### 3つの質問による問題分析
1. **何が起きたか**: 現象の正確な把握
2. **なぜ起きたか**: 根本原因の論理的分析  
3. **どう解決するか**: 最も効果的な解決策の選択

#### 段階的デバッグアプローチ
1. エラーメッセージの論理的解釈
2. 問題の最小再現ケース作成
3. 仮説立案 → 検証 → 修正のサイクル

## 🔍 TDD品質ゲート

### 必須確認事項
- [ ] 全テストがパスしている
- [ ] リント・型チェックエラーがない
- [ ] コミットメッセージが [BEHAVIOR]/[STRUCTURE] で適切に分類されている
- [ ] 日付・バージョン情報が最新かつ正確

### 完了基準
- [ ] Kent Beck原則に従った実装ができている
- [ ] 論理的思考プロセスが明確に記録されている
- [ ] 自動検証により品質が担保されている