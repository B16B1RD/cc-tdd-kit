---
description: "TDD開発環境の完全構築と実装開始"
argument-hint: "作りたいものを説明してください（例: テトリスゲーム、REST APIサーバー）"
allowed-tools: ["Write", "Read", "LS", "WebSearch", "Bash", "TodoWrite"]
---

# 統合TDD開発

要望: $ARGUMENTS

## 🎯 統合開発フロー - PDCAサイクル完全統合

このコマンドは**学習駆動開発**のための**完全なPDCAサイクル**を実現します：

### PDCAサイクルの構成

```
📋 Plan (計画) - Phase 1-3.6
├── Phase 1: 要求分析・技術選択
├── Phase 2: 環境初期化
├── Phase 3: ユーザーストーリー作成
├── Phase 3.5: 規模に応じたプロジェクト構成生成
└── Phase 3.6: MVP検証ゲート (Plan検証)

🛠️ Do (実行) - Phase 4
└── Phase 4: イテレーション実装 (学習統合型)

📈 Check (評価) - Phase 3.7
└── Phase 3.7: 強制フィードバック収集

🔄 Act (改善) - Phase 5
└── Phase 5: 学習蓄積と継続改善

     ↓
🔄 次のPDCAサイクル開始（`/tdd:run` で継続）
```

### 学習ループの保証

**従来の問題**:
```
Plan → Do → Do → Do... (学習断絶)
```

**改善された学習駆動開発**:
```
Plan → Do → Check → Act → 改善されたPlan
  ↑                         ↓
  ←←←← 継続的学習フィードバック ←←←←
```

### Kent Beck XP価値の実現

- **Communication**: 各Phaseでの内部対話・知識継承
- **Feedback**: Phase 3.7での強制フィードバック収集
- **Courage**: 各Phaseでの現実受容・変更勇気
- **Simplicity**: MVP検証による価値集中
- **Respect**: ユーザー価値・学習プロセスへの尊重

## 指示

以下の5つのPhaseを**順次実行**してください：

---

## 🔍 Phase 1: 要求の本質分析（Requirements Engineering）- PDCA「Plan」

### 1.1 5W1H + 制約分析

**ユーザーの真の目的と制約を分析**してください：

**Who（誰が）**:
- ユーザーの技術レベルを推定してください（初心者/中級者/上級者）
- 想定される使用環境を分析してください（個人/チーム/学習目的）

**What（何を）**:
- 表面的な要求文の背後にある真のニーズを特定してください
- 「本当に解決したい問題」を見つけてください

**When/Where（いつ・どこで）**:
- 使用タイミング（継続利用/一時利用/学習期間）
- 実行環境の制約（様々なマシン/特定環境/モバイル対応）

**Why（なぜ）**:
- この要求をする根本的な動機を推定してください
- 解決したい課題・得たい価値を特定してください

**How（どのように）**:
- ユーザーが理想とする体験・操作方法を想像してください

**制約分析**:
- 技術的制約（スキル、環境、リソース、権限）
- 時間的制約（開発時間、学習コスト、使用時間）  
- 配布制約（インストール、依存関係、アクセス性、共有方法）

### 1.2 Jobs-to-be-Done分析

**ユーザーが「雇いたい」ジョブを特定**してください：

**メインジョブ**:
- ユーザーが根本的に達成したいこと
- 解決したい本質的な課題

**関連ジョブ**:
- 付随的に解決したい課題
- 避けたい作業・トラブル

**感情的ジョブ**:
- 得たい感情（楽しさ、達成感、安心感）
- 避けたい感情（イライラ、不安、退屈）

**社会的ジョブ**:
- 他者との関係で得たい価値（共有、評価、貢献）

**競合分析**:
- 同じジョブを解決する他の手段との差別化ポイント

### 1.3 理想体験からの逆算設計

**摩擦ゼロの体験設計**:

1. **理想体験の定義**:
   - ユーザーが望む最終的な体験シナリオ
   - 「最高の場合、どうなるか？」

2. **摩擦ポイントの特定**:
   - 理想体験を阻む障害・面倒な作業
   - 「何が邪魔になるか？」

3. **技術選択の逆算**:
   - 摩擦を最小化する技術スタック選択
   - 「どうすれば摩擦を除去できるか？」

4. **MVP再定義**:
   - 理想体験の最小実現版
   - 「最小限で理想体験を実現するには？」

### 1.4 分析結果の統合と技術判定

**分析結果から技術スタックを決定**してください：

上記の分析結果を統合して、最適な技術選択を行ってください：

**体験重視型（摩擦ゼロ重視）**:
- ゼロインストール → 単体HTML/JSファイル
- 即座起動 → サーバーレス実行
- 環境非依存 → ブラウザ標準技術のみ
- 簡単共有 → ファイル一つで完結

**開発効率型（機能重視）**:
- 高機能 → モダンフレームワーク（React, Vue）
- 拡張性 → コンポーネント分割
- 保守性 → 開発サーバー + ビルドツール
- チーム開発 → TypeScript + 品質ツール

**学習・実験型（理解重視）**:
- 透明性 → シンプルな技術スタック（Vanilla JS）
- カスタマイズ性 → 設定可能な構造
- 段階的成長 → 拡張しやすい設計
- 理解促進 → 明確な分離とコメント

**重要な制約**:
- **JavaScriptプロジェクト**: bunまたはpnpmを使用してください。**npmは避けてください**。
- **体験重視**: 外部依存を最小化し、摩擦を除去してください。
- **学習重視**: 複雑すぎず、理解しやすい構造にしてください。

### 1.5 推奨フォルダ構造の提案

**分析結果に基づいて推奨フォルダ構造**を提示してください：

### 1.6 Kent Beck「勇気」の実践 - 現実受容と変更

**要求分析における勇気**:

```markdown
## 勇気を持った現実受容（必須）

### 技術選択変更の勇気
- [ ] 最初の技術選択が不適切と判明した場合の変更勇気
- [ ] 「既に始めたから」という沈没コスト錯誤の拒否
- [ ] ユーザー価値優先での技術妥協の拒否

### 要求見直しの勇気  
- [ ] 当初の要求理解が間違っていた場合の修正勇気
- [ ] 複雑すぎる要求の簡素化勇気
- [ ] 実現不可能な要求の現実的調整勇気

### 工数見積もりの正直さ
- [ ] 楽観的見積もりの現実的修正勇気
- [ ] 「短期間でできる」という期待への正直な対応
- [ ] 学習コスト・リスクの正直な評価

**Kent Beck**: "Courage without action is just anxiety"
```

### 1.7 プロジェクト規模の自動判定とアーキテクチャ決定

**開発キットとしての責務**: 要件分析結果から最適な構成を自動判定

#### 規模判定の5つの要素

**Phase 1分析結果から以下を評価**してください：

**1. 予想ストーリー数（最重要）**:
```markdown
## ストーリー数推定（必須）

**Jobs-to-be-Done分析結果から推定**:
- メインジョブ → 1 Story（MVP）
- 関連ジョブ → [数]個のStory
- 感情的・社会的ジョブ → [数]個のStory

**合計予想ストーリー数**: [X]個

**判定**:
- 🟢 小規模: 2-4 Stories
- 🟡 中規模: 5-8 Stories  
- 🔴 大規模: 9+ Stories
```

**2. チーム構成**:
- 👤 個人開発: 小規模傾向
- 👥 2-3人チーム: 中規模傾向
- 👥👥 4+人チーム: 大規模傾向

**3. 開発期間**:
- ⏰ 1-2週間: 小規模傾向
- 📅 1-2ヶ月: 中規模傾向
- 📆 3+ヶ月: 大規模傾向

**4. 技術的依存関係**:
- 🔗 シンプル（独立機能中心）: 小規模傾向
- 🔗🔗 中程度（一部依存あり）: 中規模傾向
- 🔗🔗🔗 複雑（高度な依存関係）: 大規模傾向

**5. 技術的複雑性**:
- 🛠️ 既知技術のみ: 小規模傾向
- 🛠️⚡ 一部新技術: 中規模傾向
- 🛠️⚡🚀 革新的技術: 大規模傾向

#### 総合判定アルゴリズム

**自動判定の実行**:

```markdown
## プロジェクト規模の総合判定（必須）

### 判定スコア計算
**各要素のスコア（1-3点）**:
- ストーリー数: [1-3]点 × 2（重み）= [X]点
- チーム構成: [1-3]点 = [X]点  
- 開発期間: [1-3]点 = [X]点
- 依存関係: [1-3]点 = [X]点
- 技術複雑性: [1-3]点 = [X]点

**合計スコア**: [X]点 / 10点満点

### 最終判定
- 🟢 **小規模プロジェクト** (3-5点): user-stories中心設計
- 🟡 **中規模プロジェクト** (6-7点): user-stories + 軽量イテレーション計画
- 🔴 **大規模プロジェクト** (8-10点): user-stories + 詳細イテレーション計画

**選択理由**: [判定に至った主要な要因を説明]
```

#### 構成決定とユーザー確認

**自動判定結果の提示**:

```markdown
## 🎯 推奨プロジェクト構成（自動判定結果）

**判定結果**: [小規模/中規模/大規模]プロジェクト

**推奨構成**:
- **進捗管理**: user-stories [+ iteration-plan]
- **フィードバック**: [軽量/標準/詳細]
- **チーム連携**: [個人向け/小チーム向け/大チーム向け]

**この判定で進めてよろしいですか？**
- ✅ **自動判定のまま進める**（推奨） 
- 🔧 **手動で調整する**（サイズアップ/ダウン）

**手動調整が必要な場合**:
- プロジェクトの特殊な制約がある
- チーム開発の経験レベルが特殊
- 組織の標準プロセスがある
```

#### Kent Beck「必要になってから」の正しい実装

**要件駆動の自動最適化**:

```markdown
## 開発キットとしてのKent Beck原則実装

### 「必要になってから」= 要件に応じた自動判定
- ❌ 機能を後で追加（ユーザー負荷）
- ✅ 要件分析時に必要性を自動判定（キット責務）

### Simplicity（シンプリシティ）の実現
- 小規模: 最小限の管理オーバーヘッド
- 中規模: 必要十分な構成管理
- 大規模: 複雑性に見合った管理機能

### 開発キット設計哲学
**ユーザーは要件を伝える、キットが最適解を提案する**

**Kent Beck**: "Simple things should be simple, complex things should be possible"
```

**体験重視型（単体ファイル）**:
```
project/
├── src/
│   ├── game.html           # 最終成果物（全て内包）
│   ├── game.js             # 開発用JavaScript  
│   └── game.css            # 開発用CSS
├── tests/
│   └── game.test.js        # テストファイル
└── package.json            # テスト環境設定のみ
```

**開発効率型（フルスタック）**:
```
project/
├── src/
│   ├── components/         # UI コンポーネント
│   ├── utils/              # 共通ユーティリティ
│   ├── styles/             # スタイルファイル
│   └── main.js             # エントリーポイント
├── tests/
├── dist/                   # ビルド出力
└── vite.config.js          # 開発環境設定
```

**学習型（段階的成長）**:
```
project/
├── step1-basic/            # 基本機能
├── step2-enhanced/         # 機能拡張
├── step3-advanced/         # 高度な機能
├── tests/
└── README.md               # 学習ガイド
```

---

## 🛠️ Phase 2: 要求分析結果に基づく環境構築 - PDCA「Plan」

### 2.1 分析結果の確認と環境選択

**Phase 1の分析結果を使用**して適切な環境を構築してください：

**分析結果の確認**:
- **体験タイプ**: 体験重視 / 開発効率重視 / 学習重視
- **技術選択**: 単体ファイル / フルスタック / 段階的構造
- **制約条件**: インストール回避 / 拡張性重視 / 理解促進

### 2.2 体験タイプ別の環境構築

**体験重視型の環境構築**:
```bash
# シンプルなディレクトリ構造（外部依存最小）
mkdir -p src tests
# package.json（テスト環境のみ）
cat > package.json << 'EOF'
{
  "name": "standalone-app",
  "version": "1.0.0", 
  "type": "module",
  "scripts": {
    "test": "vitest run",
    "test:watch": "vitest"
  },
  "devDependencies": {
    "vitest": "^1.0.0",
    "jsdom": "^24.0.0"
  }
}
EOF
```

**開発効率型の環境構築**:
```bash
# フルスタック開発環境
mkdir -p src/{components,utils,styles} tests dist
# フレームワーク + 開発ツール環境
```

**学習型の環境構築**:
```bash
# 段階的学習構造
mkdir -p step{1..3}-{basic,enhanced,advanced} tests docs
# 学習ガイド付き環境
```

### 2.3 アジャイル管理ディレクトリの作成

**既存ユーザーのマイグレーション対応**:
```bash
# 既存の .claude/agile-artifacts/ がある場合は自動移行
if [ -d ".claude/agile-artifacts" ]; then
  echo "🔄 Migrating .claude/agile-artifacts → docs/agile-artifacts"
  mkdir -p docs/
  mv .claude/agile-artifacts docs/
  echo "✅ Migration completed"
fi
```

**新規ディレクトリ作成**:
```bash
mkdir -p docs/agile-artifacts/{stories,planning,reviews,tdd-logs}
```

### 2.4 .gitignore の設定

個人用ログを除外し、チーム共有価値は含める：

```text
# TDD個人ログ（Git管理対象外）
docs/agile-artifacts/tdd-logs/

# 一般的な除外項目
node_modules/
__pycache__/
.env
.DS_Store
```

### 2.5 Git リポジトリの初期化（必要な場合）

```bash
git init
git add .gitignore
git commit -m "[INIT] TDD environment setup with agile structure"
```

### 2.6 基本テスト環境の確認

プロジェクトタイプに応じてテストコマンドを確認：

**JavaScript/TypeScript**:
```bash
# パッケージマネージャーの確認とテストスクリプト確認
if command -v bun &> /dev/null; then
  echo "推奨: bun を使用"
elif command -v pnpm &> /dev/null; then
  echo "推奨: pnpm を使用"
else
  echo "推奨: bun または pnpm のインストールを検討"
fi
```

**Python**:
```bash
# テストフレームワークの確認
python -c "import pytest" 2>/dev/null && echo "pytest 利用可能" || echo "pytest インストール推奨"
```

### 2.7 Kent Beck「勇気」の実践 - 環境決定

**環境構築における勇気**:

```markdown
## 技術的決定における勇気（必須）

### 既存環境への挑戦勇気
- [ ] より良い技術があるなら既存環境変更を恐れない
- [ ] 「慣れているから」という理由での妥協拒否
- [ ] チーム（将来の自分）の生産性向上のための変更勇気

### 複雑性排除の勇気
- [ ] 不要な依存関係の排除勇気
- [ ] 過剰な設定・ツールの簡素化勇気
- [ ] 「みんな使ってるから」という理由の疑問視

### 失敗への備えの勇気
- [ ] 実験的技術選択の失敗リスク受容
- [ ] バックアップ計画の事前準備
- [ ] 早期の方向転換を可能にする設計

**Kent Beck**: "The courage to change what isn't working"
```

---

## 📋 Phase 3: 要求分析結果に基づくストーリー作成 - PDCA「Plan」

### 3.1 Jobs-to-be-Done からストーリーへの変換

**Phase 1で特定したJobsをストーリーに変換**してください：

**メインジョブ → Story 1 (MVP Feature)**:
- **フィーチャー単位**: 2-4時間で完成可能な機能群
- ユーザーの根本的な目的を達成する最小機能セット
- Phase 1で特定した「理想体験」の最小実現版
- 例: 「基本ゲームプレイ機能」（ボード表示 + ピース操作 + 得点計算）

**関連ジョブ → Story 2-3 (Core Features)**:
- **フィーチャー単位**: 各2-4時間の統合機能
- 摩擦を除去し、体験を向上させる機能群
- ユーザーが避けたい作業・トラブルを解決するシステム
- 例: 「データ永続化システム」（保存 + 読込 + 自動保存）

**感情的・社会的ジョブ → Story 4+ (Enhancement Features)**:
- **フィーチャー単位**: 価値を高める機能セット
- 楽しさ、達成感、安心感を提供する統合機能
- 共有、評価、貢献の価値を実現する機能群
- 例: 「ソーシャル機能」（共有 + ランキング + マルチプレイ）

### 3.2 体験中心のMVPフィーチャー定義

**従来のシステム中心思考**:
❌ 「ゲームボードが表示される」（単一機能）

**フィーチャー中心思考**:
✅ 「基本的なゲームが一通り遊べる」（統合機能群）

**体験中心MVPフィーチャー定義の手順**:
1. **理想体験シナリオ**: Phase 1で定義した理想体験を使用
2. **摩擦ポイント除去**: 最大の障害となる摩擦を除去する機能群
3. **価値実現確認**: メインジョブが達成できる最小限の機能セット
4. **フィーチャー境界決定**: 「2-4時間で価値ある成果物」の境界線

**フィーチャー粒度の目安**:
- **小さすぎる❌**: 「ボタンを表示」（10分）
- **適切な粒度✅**: 「ユーザー認証システム」（2-3時間）
- **大きすぎる❌**: 「完全なECサイト」（数週間）

### 3.3 要求分析結果の統合

**Phase 1の分析結果を活用**してストーリーを具体化：

**5W1H分析結果の活用**:
- Who → ユーザータイプの明確化
- What → 機能要求の具体化  
- When/Where → 使用コンテキストの反映
- Why → 価値・理由の明確化
- How → 操作方法・体験の設計

**制約分析結果の反映**:
- 技術制約 → 実装可能性の考慮
- 時間制約 → 優先度・工数の調整
- 配布制約 → アクセス方法・共有方法の設計

### 3.3 受け入れ基準の定義

各ストーリーに具体的な**受け入れ基準 (Acceptance Criteria)**を定義：

```
GIVEN [前提条件]
WHEN [実行操作]  
THEN [期待結果]
```

### 3.4 ストーリーファイルの作成

`docs/agile-artifacts/stories/` ディレクトリに以下の形式でファイルを作成：

**ファイル名**: `user-stories-v1.0.md`

**テンプレート**:
```markdown
# ユーザーストーリー v1.0

**プロジェクト**: [要望名]
**作成日**: [今日の日付]
**技術スタック**: [選択した技術]
**イテレーション単位**: フィーチャー（2-4時間）

## Story 1: MVP Feature - [フィーチャー名]

**ストーリー**:
As a [ユーザー]
I want [統合機能群]
So that [価値ある体験]

**フィーチャー内容** (2-4時間で完成):
- [ ] [コア機能1] - 基本的な動作
- [ ] [コア機能2] - ユーザー操作
- [ ] [コア機能3] - フィードバック表示
- [ ] [統合テスト] - 一連の流れ確認

**受け入れ基準**:
- [ ] GIVEN 初期状態 WHEN 基本操作 THEN 期待する体験が得られる
- [ ] GIVEN エラー状態 WHEN リカバリ操作 THEN 正常に回復する
- [ ] [追加の統合基準...]

**優先度**: 🔥 CRITICAL (MVP)
**工数見積**: 2-3時間（機能開発 + 統合テスト）

## Story 2: Core Feature - [フィーチャー名]
[同様の形式...]

## Story 3: Core Feature - [フィーチャー名] 
[同様の形式...]

## フィーチャー分割の例

### 🎮 ゲーム開発の場合
- **Story 1**: 基本ゲームプレイ（ボード + ピース + 操作 + 得点）
- **Story 2**: ゲーム進行管理（開始 + 終了 + レベル + 状態保存）
- **Story 3**: ユーザー体験向上（効果音 + アニメーション + UI改善）

### 🌐 Web開発の場合
- **Story 1**: ユーザー認証システム（登録 + ログイン + セッション + 基本画面）
- **Story 2**: コンテンツ管理（CRUD + 検索 + ページング + 権限）
- **Story 3**: ユーザー間交流（コメント + いいね + 通知 + プロフィール）

### 📱 API開発の場合
- **Story 1**: リソース基本操作（エンドポイント + CRUD + バリデーション + エラー処理）
- **Story 2**: 認証・認可システム（トークン + ロール + アクセス制御 + ログ）
- **Story 3**: 高度な機能（検索 + フィルタ + ページネーション + キャッシュ）
```

### 3.5 規模に応じたプロジェクト構成生成

**Phase 1の規模判定結果を基に、最適なプロジェクト構成を自動生成**

#### 規模判定結果の確認

**Phase 1.7で実施した規模判定を確認**してください：

```markdown
## 規模判定結果の確認（必須）

**Phase 1.7の判定結果**:
- **最終判定**: [🟢小規模/🟡中規模/🔴大規模]プロジェクト
- **判定スコア**: [X]点 / 10点満点
- **主要判定要因**: [ストーリー数/チーム規模/期間/複雑性]

この判定に基づいて、適切なプロジェクト構成を生成します。
```

#### 小規模プロジェクト (🟢 3-5点) の構成

**判定条件**: 2-4 Stories、個人開発、1-2週間

**生成される構成**:
- ✅ **user-stories-v1.0.md**: 詳細管理（現在の形式）
- ❌ **iteration-plan**: 生成しない（管理オーバーヘッド回避）
- ✅ **軽量フィードバック**: Phase 3.7の3つの質問のみ

**Kent Beck原則との整合性**:
- **Simplicity**: 必要最小限の管理文書
- **Communication**: user-storiesによる内部対話に集中
- **Feedback**: 実装を通じた短サイクルフィードバック

**実行指示**:
```markdown
🟢 **小規模プロジェクト構成**

**生成ファイル**:
- user-stories-v1.0.md（既に作成済み）

**スキップされる機能**:
- イテレーション計画（必要時に手動作成可能）
- 複雑なフィードバックシステム
- チーム管理機能

**次のPhaseへ**: Phase 3.6（MVP検証ゲート）に進んでください。
```

#### 中規模プロジェクト (🟡 6-7点) の構成

**判定条件**: 5-8 Stories、2-3人チーム、1-2ヶ月

**生成される構成**:
- ✅ **user-stories-v1.0.md**: 詳細管理（現在の形式 + 拡張）
- ✅ **iteration-plan-v1.0.md**: 軽量テンプレート使用
- ✅ **標準フィードバック**: Phase 3.7 + 週次レビュー

**生成プロセス**:
```bash
# 軽量イテレーション計画の生成
cp ~/.claude/commands/shared/iteration-plan-medium.md docs/agile-artifacts/planning/iteration-plan-v1.0.md

# プロジェクト固有情報の置換
sed -i 's/\[プロジェクト名\]/'$PROJECT_NAME'/g' docs/agile-artifacts/planning/iteration-plan-v1.0.md
sed -i 's/\[作成日\]/'$(date +%Y-%m-%d)'/g' docs/agile-artifacts/planning/iteration-plan-v1.0.md
```

**実行指示**:
```markdown
🟡 **中規模プロジェクト構成**

以下を実行してください：

1. **軽量イテレーション計画の生成**:
   ```bash
   cp ~/.claude/commands/shared/iteration-plan-medium.md docs/agile-artifacts/planning/iteration-plan-v1.0.md
   ```

2. **プロジェクト情報の設定**:
   - [プロジェクト名] → 実際のプロジェクト名
   - [作成日] → 今日の日付
   - [5-8] → 実際のストーリー数
   - [1-2ヶ月] → 実際の期間
   - [2-3人] → 実際のチーム構成

3. **user-storiesとの整合性確認**:
   - イテレーション計画のマイルストーンがuser-storiesのStoryと対応
   - 重複情報は参照関係で管理

**生成ファイル**:
- stories/user-stories-v1.0.md（メイン管理）
- planning/iteration-plan-v1.0.md（マイルストーン・リスク管理）

**次のPhaseへ**: Phase 3.6（MVP検証ゲート）に進んでください。
```

#### 大規模プロジェクト (🔴 8-10点) の構成

**判定条件**: 9+ Stories、4+人チーム、3+ヶ月

**生成される構成**:
- ✅ **user-stories-v1.0.md**: 詳細管理（現在の形式 + 大規模拡張）
- ✅ **iteration-plan-v1.0.md**: 詳細テンプレート使用
- ✅ **包括的フィードバック**: 多軸フィードバック + チーム管理

**生成プロセス**:
```bash
# 詳細イテレーション計画の生成
cp ~/.claude/commands/shared/iteration-plan-large.md docs/agile-artifacts/planning/iteration-plan-v1.0.md

# チーム管理ディレクトリの作成
mkdir -p docs/agile-artifacts/planning/{team-coordination,risk-management,communication}
```

**実行指示**:
```markdown
🔴 **大規模プロジェクト構成**

以下を実行してください：

1. **詳細イテレーション計画の生成**:
   ```bash
   cp ~/.claude/commands/shared/iteration-plan-large.md docs/agile-artifacts/planning/iteration-plan-v1.0.md
   ```

2. **追加管理ディレクトリの作成**:
   ```bash
   mkdir -p docs/agile-artifacts/planning/{team-coordination,risk-management,communication}
   ```

3. **プロジェクト情報の詳細設定**:
   - チーム構成・役割分担の具体化
   - マイルストーンの詳細スケjュール設定
   - リスク管理項目の具体化
   - コミュニケーション計画の設定

4. **ステークホルダーとの調整**:
   - プロダクトオーナーの確認
   - チームリーダーとの合意
   - プロジェクトマネージャーとの調整

**生成ファイル**:
- stories/user-stories-v1.0.md（詳細進捗管理）
- planning/iteration-plan-v1.0.md（包括的プロジェクト管理）
- planning/team-coordination/（チーム管理）
- planning/risk-management/（リスク管理）
- planning/communication/（コミュニケーション管理）

**次のPhaseへ**: Phase 3.6（MVP検証ゲート）に進んでください。
```

#### 手動調整オプション

**自動判定結果の調整が必要な場合**:

```markdown
## 手動調整の実行（必要な場合）

### サイズアップ調整
**小規模 → 中規模**:
- 理由: [チーム参加/長期運用予定/等]
- 実行: 中規模構成の手順を実行

**中規模 → 大規模**:
- 理由: [組織要件/コンプライアンス/等]
- 実行: 大規模構成の手順を実行

### サイズダウン調整
**大規模 → 中規模**:
- 理由: [リソース制約/シンプル化優先/等]
- 実行: 中規模構成の手順を実行（後でアップグレード可能）

**中規模 → 小規模**:
- 理由: [個人開発/プロトタイプ/等]
- 実行: 小規模構成の手順を実行

### 調整記録
- **調整理由**: [具体的な理由]
- **調整内容**: [自動判定 → 手動調整]
- **将来の見直し**: [条件が変わった場合の再評価タイミング]
```

#### Kent Beck「必要になってから」の完全実装

**開発キットとしての設計哲学の実現**:

```markdown
## 開発キット設計の完成

### 自動最適化の実現
- ユーザー: 要件を伝える
- キット: 規模を自動判定
- キット: 最適構成を自動生成
- ユーザー: 確認・調整のみ

### Kent Beck原則の実装
**Simplicity**: 各規模に最適化された構成
**Communication**: 規模に応じた適切なコミュニケーション設計
**Feedback**: 規模に応じた適切なフィードバック設計
**Courage**: 規模変更時の構成変更を恐れない
**Respect**: ユーザーの認知負荷を最小化

### 「必要になってから」の正しい解釈
❌ 機能を後で追加（ユーザー負荷）
✅ 要件に応じた最適構成を自動提案（キット責務）

**Kent Beck**: "Simple things should be simple, complex things should be possible"
```

---

## 🔍 Phase 3.6: MVP検証ゲート - 批判的レビュー - PDCA「Plan検証」

### 役割転換指示

**重要**: ここから視点を完全に切り替えてください。

あなたは今から **「悪魔の代弁者（Devil's Advocate）」** として、作成されたMVPストーリーを批判的に検証する外部コンサルタントです。

### 検証者ロールの設定

以下のロールからランダムに1つを選択し、その視点で厳格に検証してください：

**🎮 実際のユーザー視点**:
- 「これで本当に遊べる/使えるの？」
- 「期待してたのと違う！」
- 「5分で飽きない？」

**💰 投資家視点**:
- 「これで市場価値があるの？」
- 「競合に勝てる？」
- 「お金を出す価値ある？」

**🏆 競合開発者視点**:
- 「これなら簡単に勝てる」
- 「手抜きすぎ」
- 「基本機能が欠けてる」

**😈 意地悪なQA視点**:
- 「最悪のケースで破綻しない？」
- 「エッジケースは考慮済み？」
- 「ユーザビリティ最悪じゃない？」

### MVP製品完全性チェック

作成されたStory 1（MVPフィーチャー）に対して、以下を厳格にチェックしてください：

#### 1. 製品アイデンティティチェック

- [ ] これは単独で「[製品名]」と呼べるか？
- [ ] 競合製品の最小バージョンと比較して劣っていないか？
- [ ] ユーザーが期待する基本体験を満たしているか？

#### 2. ドメイン別必須要素チェック

**ゲーム開発の場合**:
- [ ] ゲームループが成立する（開始→プレイ→終了）
- [ ] 失敗のリスクがある（ゲームオーバー条件）
- [ ] プレイヤーの意思決定が結果に影響する
- [ ] 継続プレイのモチベーションがある

**Webアプリの場合**:
- [ ] ユーザーが目的を達成できる完全なフロー
- [ ] エラー時のリカバリー手段
- [ ] データの永続性（必要な場合）
- [ ] 基本的なユーザビリティ

**API/ツールの場合**:
- [ ] 実用的な問題を実際に解決できる
- [ ] エラーハンドリングが適切
- [ ] ドキュメント・使用例が十分
- [ ] セキュリティ基準を満たす

#### 3. 破壊的質問リスト

以下の**すべての質問**に**自信を持って「YES」**と答えられるまで、次のPhaseに進むことは**禁止**されています：

**汎用的価値検証質問**:
1. 「実際のユーザーが5分間使って、目的を達成できるか？」
2. 「友人に見せて、恥ずかしくない品質に達しているか？」
3. 「競合製品/既存手段と比較して、明確な優位性があるか？」
4. 「技術的都合でユーザー価値を犠牲にしていないか？」
5. 「これは『動く』だけでなく『使える』状態に達しているか？」

**ドメイン別具体的質問**:

**ゲーム開発の場合**:
- 「5分間楽しく遊び続けられるか？」

**Webアプリの場合**:
- 「ユーザーが想定した作業を最後まで完了できるか？」

**API開発の場合**:
- 「実際の業務問題を解決できるか？」

**CLI/ツール開発の場合**:
- 「手作業より明らかに効率的か？」

### 検証結果の判定

#### PASS条件

- 全てのチェック項目がクリア
- 破壊的質問に自信を持って「YES」
- 検証者ロールから見ても許容できる品質

#### FAIL条件の処理

**FAIL判定の場合、以下の形式で報告**:

```
🚨 MVP検証失敗

検証者: [選択したロール]
判定理由: [具体的な問題点]

欠落している必須要素:
1. [具体的な機能名]: [なぜ必須かの理由]
2. [具体的な機能名]: [なぜ必須かの理由]
3. [具体的な機能名]: [なぜ必須かの理由]

修正案:
- Story 1に追加すべき機能: [具体的な提案]
- 実装順序の変更提案: [具体的な提案]
- 受け入れ基準の修正: [具体的な提案]

修正後、再度この検証を実行することを強く推奨します。
```

### 自己検証トリガー

Story 1作成完了後、必ず以下を自問してください：

1. **製品性チェック**: 「もし私がユーザーなら、これで満足するか？」
2. **価値優先チェック**: 「技術的都合で、価値を犠牲にしていないか？」
3. **完全性チェック**: 「『動く』と『使える』を混同していないか？」
4. **競合比較チェック**: 「既存の類似製品と比べて劣っていないか？」

**もし少しでも疑問があれば、このPhase 3.6を必ず実行してください。**

### 検証通過の確認（強制実行）

**⚠️ 重要**: このPhase 3.6は**必須プロセス**です。検証を回避することはできません。

#### ✅ PASS判定の場合

**のみ**Phase 4への進行が許可されます。

#### ❌ FAIL判定の場合

**Phase 4への進行は絶対に禁止**されています。以下を実行してください：

1. **即座に実装を停止**
2. **Phase 3に戻ってStory 1を根本的に見直し**
3. **欠落している必須要素を追加**
4. **受け入れ基準を現実的に修正**
5. **再度Phase 3.6を実行**

**注意**: FAIL状態での作業継続は、時間とリソースの無駄遣いです。勇気を持って計画を修正してください。

### 検証実行の強制

この検証は**スキップ・延期・省略することができません**：
- 「時間がないから後で」→ **禁止**
- 「だいたい動くから大丈夫」→ **禁止**  
- 「完璧じゃないけど進める」→ **禁止**

**Kent Beck**: "勇気を持って現実を受け入れ、必要な変更を恐れるな"

---

## 📝 Phase 3.7: 即座学習記録 - 実用的フィードバック - PDCA「Check」

### 実行可能な学習記録システム

**重要**: この学習記録は**各Phase完了と同時に即座実行**します。

Phase完了した瞬間に、**5分以内**で完了する最小限の学習記録を行います。

### 即座実行の3つの質問（必須・5分完了）

各Phase完了時に、以下の**3つの質問のみ**に答えてください：

```markdown
## 即座学習記録 - [Phase名] - [日時]

### 1. 予想との違い（2分）
**Q: 実装前の予想と実際の違いは？**
A: [想定より難しかった/簡単だった/予想通り] - [理由を1-2行]

### 2. 重要な発見（2分）  
**Q: 次回に活かせる最も重要な発見は？**
A: [技術・プロセス・価値に関する発見を1-2行]

### 3. 次の優先度（1分）
**Q: この結果を受けて、次の優先度は変わるか？**
A: [変わらない/変更あり] - [変更の場合は新しい優先度を1行]
```

### 実行方法の実用化（自動化スクリプト）

#### Phase完了時の1コマンド実行

**自動化スクリプトで簡単実行**:
```bash
# Phase完了直後に即座実行（ファイルパスは自動検出）
bash ~/.claude/commands/shared/quick-feedback.sh "Phase1" "docs/agile-artifacts/stories/user-stories-v1.0.md"
```

**使用例**:
```bash
# ゲームボード描画完了後
bash ~/.claude/commands/shared/quick-feedback.sh "ゲームボード描画"

# テトリミノ操作完了後
bash ~/.claude/commands/shared/quick-feedback.sh "テトリミノ操作"
```

**メリット**:
- ✅ **5秒で開始**: コマンド1行で即座開始
- ✅ **選択式回答**: タイピング最小限
- ✅ **自動追記**: user-storiesへの正確なフォーマット追記
- ✅ **完了ガイダンス**: 次のアクションを明示

**実行フロー (5分以内)**:
1. コマンド実行 (5秒)
2. 3つの質問に回答 (4分)
3. 自動追記確認 (30秒)
4. チェックボックス更新 (30秒)

### 自動化スクリプトの機能

**スクリプトの特徴**:
- 🚀 **選択式回答**: タイピング量を最小限に削減
- 📁 **ファイル自動検出**: user-storiesファイルパスを自動判定
- ✅ **フォーマット統一**: 正確なフォーマットで追記
- 🎯 **次アクション提示**: フィードバック後の具体的手順を表示

**記録例**:
```markdown
## 学習記録 - ゲームボード描画 - 2025-08-01 14:30
1. 予想との違い: 想定より簡単だった - Canvas APIが予想より直感的
2. 重要な発見: requestAnimationFrameの重要性を実感
3. 次の優先度: 変わらない
```

### 継続的ストーリー更新（簡素化）

**更新方法**:
1. **Phase完了時**: チェックボックス更新 + 1行コメント
2. **重要発見時**: 該当箇所に「※発見: [内容]」を追記
3. **計画変更時**: 受け入れ基準・優先度を直接修正

**更新例**:
```markdown
- [x] ゲームボード描画 ✅ 完了 - 25分 - ※Canvas APIの習得が予想より簡単
- [x] テトリミノ操作 ✅ 完了 - 40分 - ※衝突判定が複雑、次回は事前調査必要
```

### 学習記録の強制実行

**各Phase完了チェックリスト**:
```markdown
## Phase完了チェックリスト（5分以内完了）

- [ ] 機能が動作することを確認
- [ ] 3つの質問に回答（2分）
- [ ] user-storiesに学習記録追記（2分）
- [ ] チェックボックス更新（1分）
- [ ] 次Phaseの優先度確認

**このチェックリスト完了なしに次Phaseへの進行は禁止**
```

### フィードバック収集の現実化

**従来の問題**:
- 複雑な4軸フィードバック → **実行されない**
- 別ファイル作成 → **手間が多すぎる**
- 長時間の振り返り → **時間がない**

**改善後**:
- シンプルな3つの質問 → **5分で完了**
- 既存ファイルに追記 → **手間最小**
- 即座実行 → **忘れない**

**Kent Beck**: "Simple things should be simple, complex things should be possible"

---

## 🛠️ Phase 4: TDD統合実装 - PDCA「Do」

### **⚠️ 重要警告**: このPhaseでは**一括実装は絶対禁止**です

Kent Beck TDD原則を厳格に適用します：
1. **失敗するテストなしにプロダクションコードを書いてはならない**
2. **小さなステップで確実に進む**  
3. **Fake It戦略を60%以上で使用**

### 4.1 受け入れ基準のテスト化（強制実行）

**user-storiesの受け入れ基準を実行可能テストに変換**してください：

#### Step 1: 最初の受け入れ基準を特定

user-storiesファイルから**最初の受け入れ基準**を取り出し、テストケースに変換：

```javascript
// 例: GIVEN ゲーム開始 WHEN 5分間プレイ THEN 上級者・初心者ともに満足する体験が得られる
// ↓ テスト化
describe('Game Basic Experience', () => {
  it('should display game board when game starts', () => {
    // 最初のテスト: ゲームボードが表示される
    const game = new TetrisGame(canvas);
    expect(game.board).toBeDefined();
    expect(game.board.width).toBe(10);
    expect(game.board.height).toBe(20);
  });
});
```

#### Step 2: テスト実行（Red）

```bash
# テストを実行して失敗することを確認
bun test
# -> FAIL: TetrisGame is not defined
```

#### Step 3: Fake It実装（Green）

**Kent Beck Fake It戦略**：最小限のハードコーディング実装

```javascript
// 最小限のハードコード実装
class TetrisGame {
  constructor(canvas) {
    this.board = {
      width: 10,
      height: 20
    };
  }
}
```

#### Step 4: テスト通過確認（Green）

```bash
bun test
# -> PASS: 1 test passed
```

#### Step 5: 次のテスト追加（Red）

```javascript
it('should draw game board on canvas', () => {
  const canvas = document.createElement('canvas');
  const game = new TetrisGame(canvas);
  game.draw();
  
  // Canvas contextが使用されたかチェック
  expect(canvas.getContext('2d')).toBeDefined();
});
```

### 4.2 Kent Beck三大戦略の強制適用

#### Fake It戦略（60%以上で使用・強制）

**実装方法が不明確な場合**：

```javascript
// ❌ 間違い: いきなり正しい実装
function calculateScore(lines) {
  return lines * 100 * level; // 複雑すぎる
}

// ✅ 正しい: Fake It戦略
function calculateScore(lines) {
  return 100; // 完全にハードコード
}
```

#### Triangulation戦略（2つ目のテストで一般化）

```javascript
// 1つ目のテスト
it('should return 100 for single line clear', () => {
  expect(calculateScore(1)).toBe(100);
});

// 2つ目のテスト追加でハードコードを破る
it('should return 200 for double line clear', () => {
  expect(calculateScore(2)).toBe(200);
});

// Triangulationで一般化
function calculateScore(lines) {
  return lines * 100; // ようやく正しい実装
}
```

#### Obvious Implementation戦略（自明な場合のみ）

```javascript
// 数学的に自明な場合のみ
function square(x) {
  return x * x; // 1行で完結、自明
}
```

### 4.3 Red-Green-Refactorサイクルの段階的実行

#### 各受け入れ基準に対して以下を**必ず実行**：

**Cycle 1: ゲームボード描画**
```
Red   → テスト作成: ゲームボードが表示される
Green → Fake It: 固定サイズのボード表示のみ
Refactor → 変数名の改善、コメント追加
Commit → [BEHAVIOR] Add basic game board display
```

**Cycle 2: テトリミノ生成**
```
Red   → テスト作成: テトリミノが1個生成される
Green → Fake It: Iピース固定で生成
Refactor → 定数の抽出、メソッド分離
Commit → [BEHAVIOR] Add I-piece generation
```

**Cycle 3: テトリミノ操作**
```
Red   → テスト作成: テトリミノが左に移動する
Green → Fake It: position -= 1 のみ
Refactor → 境界チェック追加
Commit → [BEHAVIOR] Add left movement
```

### 4.4 小さなステップの強制実行

#### ❌ 禁止される大きなステップ：

```javascript
// 一度に全機能を実装（禁止）
class TetrisGame {
  constructor() {
    this.initBoard();
    this.initPieces();
    this.initControls();
    this.initScoring();
    this.initRenderer();
    // ... 100行以上の実装
  }
}
```

#### ✅ 正しい小さなステップ：

```javascript
// Step 1: ボードのみ
class TetrisGame {
  constructor() {
    this.board = Array(20).fill(null).map(() => Array(10).fill(0));
  }
}

// Step 2: 1個のピース追加
class TetrisGame {
  constructor() {
    this.board = Array(20).fill(null).map(() => Array(10).fill(0));
    this.currentPiece = [[1,1,1,1]]; // Iピース固定
  }
}

// Step 3: 移動機能追加
class TetrisGame {
  // ... 前のコード
  moveLeft() {
    this.pieceX -= 1; // 最小限の実装
  }
}
```

### 4.5 実装順序の具体的指定

**Story 1の受け入れ基準を以下の順序で実装**：

#### Phase 4.1: 基本表示（30分目標）
1. **Red**: ゲームボード表示テスト
2. **Green**: Canvas要素 + 固定グリッド描画
3. **Refactor**: 描画コードの整理
4. **Commit**: `[BEHAVIOR] Add game board display`

#### Phase 4.2: ピース生成（45分目標）
1. **Red**: テトリミノ1個生成テスト
2. **Green**: Iピース固定生成
3. **Red**: テトリミノ表示テスト  
4. **Green**: 固定位置に描画
5. **Refactor**: ピース定数の抽出
6. **Commit**: `[BEHAVIOR] Add tetrimino generation and display`

#### Phase 4.3: 基本操作（60分目標）
1. **Red**: 左移動テスト
2. **Green**: position.x -= 1（境界チェックなし）
3. **Red**: 境界チェックテスト
4. **Green**: 境界条件の追加
5. **Refactor**: 操作メソッドの整理
6. **Commit**: `[BEHAVIOR] Add basic movement with boundary check`

#### Phase 4.4: 落下システム（45分目標）
1. **Red**: 自動落下テスト
2. **Green**: setInterval固定速度
3. **Red**: 底面衝突テスト
4. **Green**: 単純な衝突判定
5. **Refactor**: タイマー管理の改善
6. **Commit**: `[BEHAVIOR] Add automatic falling system`

### 4.6 user-storiesリアルタイム更新

**各Phase完了と同時に**user-storiesを更新：

```markdown
**フィーチャー内容** (4-5時間で完成): 🔄 **実装中**
- [x] **ゲームボード描画** ✅ 完了 - 25分 - ※Canvas習得が予想より簡単
- [x] **テトリミノ生成システム** ✅ 完了 - 40分 - ※固定ピースから開始で効率的
- [ ] **ゴーストピース表示** 🔄 実装中 - 予想30分
- [ ] **テトリミノ操作** - 予想45分
```

### 4.7 学習記録の継続実行

**各Phase完了時に自動化スクリプト実行**：

```bash
# Phase 4.1完了後
bash ~/.claude/commands/shared/quick-feedback.sh "ゲームボード描画"

# Phase 4.2完了後  
bash ~/.claude/commands/shared/quick-feedback.sh "テトリミノ生成"
```

### 4.8 実装完了の厳格な定義

#### ✅ 実装完了の条件（全て必須）

1. **全テストが通る**
2. **受け入れ基準が実際に動作する**
3. **5分間のユーザー体験テスト通過**
4. **Phase 3.6 MVP検証ゲート再実行でPASS**
5. **user-stories完全更新**
6. **学習記録完了**

#### ❌ 完了とみなされない状態

- テストは通るが実際に使えない
- 基本機能は動くが品質が低い
- 実装は終わったが学習記録なし
- 一部の機能のみで受け入れ基準未達成

### 4.9 継続実装案内の自動化

**Story 1完了時の案内**：

```markdown
🎉 Story 1 (MVP Feature) 実装完了！

📊 実装結果:
- 実装時間: [実績]時間（見積: 4-5時間）
- TDDサイクル数: [X]回
- 主要な学習: [発見事項]

🚀 次のアクション:

**引数なしで簡単継続**（推奨）:
```
/tdd:run
```

**手動で次の機能指定**:
```
/tdd:run Story2のデータ永続化システム
```

**新しいプロジェクト開始**:
```
/tdd [新しい要望]
```
```

### 4.10 TDD原則違反の防止システム

#### 自動チェックリスト（各実装前に確認）

```markdown
## TDD原則チェック（必須確認）

### Kent Beck 3つのルール
- [ ] 失敗するテストを書いたか？
- [ ] そのテストが正確に失敗することを確認したか？
- [ ] テストを通す最小限の実装のみ書いたか？

### 実装サイズチェック  
- [ ] 1度の実装が10行以下か？
- [ ] 1つの機能のみに集中しているか？
- [ ] 「動く」と「完璧」を混同していないか？

### Fake It戦略チェック
- [ ] 実装方法が不明確な場合、ハードコードから始めたか？
- [ ] 複雑なロジックを一度に書こうとしていないか？
- [ ] 2つ目のテストでハードコードを破る準備はできているか？
```

**このチェックリストを通らない限り、実装を開始してはいけません。**

---

## 📈 Phase 5: 学習蓄積と継続改善 - PDCA「Act」

### PDCAサイクルの完成

このPhaseは、Phase 1-4で得られた**すべての学習を蓄積**し、**次のイテレーションに活かす**ための**Act（改善）フェーズ**です。

### 5.1 全体的学習の統合と評価

**Phase 1-4で蓄積された学習の統合**:

```markdown
## 学習統合レポート作成（必須）

### 技術的学習の評価
**最も重要な技術的発見**:
- [ ] 想定外の技術的制約とその解決策
- [ ] 効果的だった技術・手法・ツール
- [ ] 避けるべき技術的な落とし穴
- [ ] パフォーマンス・互換性の知見

**実装効率の分析**:
- [ ] 時間がかかった作業とその理由
- [ ] 効率的に進んだ作業とその要因
- [ ] デバッグ・トラブルシューティングの学習
- [ ] コード品質向上のポイント

### ユーザー価値の評価
**価値実現の成功・失敗分析**:
- [ ] 想定した価値の実現度（1-5点評価）
- [ ] ユーザー体験の満足度評価
- [ ] 競合・既存手段との優位性評価
- [ ] 改善すべきユーザビリティ課題

**MVP定義の精度評価**:
- [ ] 最初のMVP定義は適切だったか？
- [ ] 実装してみて分かった真の必須機能
- [ ] 過剰だった機能・不足していた機能
- [ ] 次回のMVP定義改善ポイント

### プロセス改善の評価
**TDDプロセスの効果測定**:
- [ ] Red-Green-Refactorサイクルの効果
- [ ] Kent Beck戦略（Fake It/Triangulation/Obvious）の適用効果
- [ ] テストファースト開発の困難点と解決策
- [ ] リファクタリングのタイミングと効果

**フィードバックループの効果測定**:
- [ ] Phase 3.6 MVP検証ゲートの有効性
- [ ] Phase 3.7 フィードバック収集の効果
- [ ] 継続的ストーリー更新の価値
- [ ] 計画修正の勇気の実践度
```

### 5.2 次期イテレーション計画の最適化

**学習に基づく計画改善**:

```markdown
## 次期イテレーション最適化（必須）

### 工数見積もりの精度向上
**見積もり精度の分析**:
- 予想工数: [X時間] → 実績工数: [Y時間]
- 差異要因: [具体的な理由]
- 改善策: [次回の見積もり方法]

**隠れた複雑性の特定**:
- [ ] 見落としていた依存関係
- [ ] 想定外の学習コスト
- [ ] 統合時の調整コスト
- [ ] テスト・デバッグコスト

### 優先度の再評価
**価値の優先順位見直し**:
- [ ] 実装してみて価値が高かった機能
- [ ] 実装してみて価値が低かった機能
- [ ] ユーザーが本当に求めている機能
- [ ] 技術的負債となりそうな機能

**リスクの再評価**:
- [ ] 技術的リスクの見直し
- [ ] 工数リスクの見直し
- [ ] ユーザビリティリスクの見直し
- [ ] 統合リスクの見直し
```

### 5.3 知識資産の永続化

**組織学習の蓄積**:

```markdown
## 知識資産化（必須）

### ドキュメント更新（Single Source of Truth）
**user-stories の最終統合更新**:
- [ ] 実装結果に基づく最終状態の記録
- [ ] 発見した課題の完全な記録
- [ ] 次期イテレーションへの引き継ぎ事項
- [ ] 成功・失敗要因の分析結果
- [ ] 学習記録の整理・統合

**技術ドキュメントの作成**:
- [ ] アーキテクチャ決定記録（ADR）
- [ ] API仕様・使用方法
- [ ] セットアップ・デプロイ手順
- [ ] トラブルシューティングガイド

### 学習ライブラリの構築
**再利用可能な知識の抽出**:
- [ ] 汎用的な技術パターン
- [ ] ドメイン固有の知見
- [ ] 効果的な開発プロセス
- [ ] 避けるべき落とし穴集
```

### 5.4 継続的改善の文化構築

**Kent Beck XP価値の実践評価**:

```markdown
## XP価値の実践度評価

### Communication（コミュニケーション）
- [ ] 内部対話（計画者↔実装者）の効果
- [ ] ドキュメントによる知識伝達の精度
- [ ] 将来の自分への情報継承の品質

### Feedback（フィードバック）
- [ ] 継続的フィードバック収集の効果
- [ ] ユーザー視点での価値評価の精度
- [ ] 技術的フィードバックの活用度

### Courage（勇気）
- [ ] 計画変更への勇気の実践度
- [ ] 現実受容の勇気の発揮度
- [ ] 品質基準の妥協拒否の勇気

### Simplicity（シンプリシティ）
- [ ] 必要最小限の実装への集中度
- [ ] 過剰設計の回避度
- [ ] ユーザー価値への集中度

### Respect（尊重）
- [ ] ユーザーニーズへの尊重度
- [ ] 自分の学習・成長への尊重度
- [ ] プロセス・原則への尊重度
```

### 5.5 成功指標の達成評価と次期目標設定

**最終成果の客観的評価**:

```markdown
## 成功指標達成度評価

### MVP成功指標の達成度
- [ ] ユーザーが5分間価値を感じて使用できる
- [ ] 友人に見せて恥ずかしくない品質
- [ ] 競合・既存手段との明確な差別化
- [ ] 技術的都合での価値犠牲なし

### プロセス成功指標の達成度
- [ ] 計画通りの工数での完成
- [ ] 品質ゲートのクリア
- [ ] 継続的学習の実践
- [ ] チーム（将来の自分）への知識継承

### 次期イテレーション目標の設定
**学習に基づく現実的目標**:
- [ ] 次の価値実現目標
- [ ] 改善された工数見積もり
- [ ] 強化すべきスキル・知識領域
- [ ] プロセス改善の具体的施策
```

### 5.6 完了宣言と次期開始準備

```text
🎉 学習駆動開発イテレーション完了！

📊 学習成果（Single Source of Truth）:
├── docs/agile-artifacts/
│   ├── stories/user-stories-v[X.Y].md     # 統合管理（進捗・学習・計画）
│   ├── reviews/feedback-[日付].md         # 補足フィードバック
│   └── knowledge/lessons-learned-[日付].md # 知識資産
│
│   ※ user-storiesに全て統合されているため、iteration-planは不要

🎯 達成成果:
- **MVP価値実現**: [具体的な成果]
- **技術学習**: [重要な技術的発見]
- **プロセス改善**: [改善されたプロセス]
- **次期準備**: [次のイテレーション最適化]

🚀 次期イテレーション準備完了

蓄積された学習に基づき、より効果的な次のイテレーションを開始します。

## 次期イテレーション開始コマンド

学習に基づいて最適化された次の開発フェーズ：

```bash
/tdd [次のStoryまたは機能要望]
```

**継続実装（自動判別）**:

```bash
/tdd:run
```

### コマンド使い分けガイド

**`/tdd`を使うべき時**:
- ✅ 新しいプロジェクトの開始
- ✅ 新しいStoryの作成が必要
- ✅ 要求分析から始めたい
- ✅ 環境構築が必要

**`/tdd:run`を使うべき時**:
- ✅ 既存のuser-storiesがある
- ✅ 環境が構築済み
- ✅ Storyの継続実装
- ✅ **引数なしで自動判別**

**一般的なフロー**:
```
1. /tdd [要望]           # 初回のみ（統合開発）
2. /tdd:run                # 継続実装（次の機能を自動判別）
3. /tdd:run                # さらに継続（全て自動）
4. /tdd:run                # 最後まで簡単
```

**Kent Beck**: "Software development is a learning game"
```