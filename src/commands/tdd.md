---
description: "TDD開発環境の完全構築と実装開始"
argument-hint: "作りたいものを説明してください（例: テトリスゲーム、REST APIサーバー）"
allowed-tools: ["Write", "Read", "LS", "WebSearch", "Bash", "TodoWrite"]
---

# 統合TDD開発

要望: $ARGUMENTS

## 🎯 統合開発フロー - PDCAサイクル完全統合

このコマンドは**学習駆動開発**のための**完全なPDCAサイクル**を実現します：

### PDCAサイクルの構成

```
📋 Plan (計画) - Phase 1-3.5
├── Phase 1: 要求分析・技術選択
├── Phase 2: 環境初期化
├── Phase 3: ユーザーストーリー作成
└── Phase 3.5: MVP検証ゲート (Plan検証)

🛠️ Do (実行) - Phase 4
└── Phase 4: イテレーション実装 (学習統合型)

📈 Check (評価) - Phase 3.6
└── Phase 3.6: 強制フィードバック収集

🔄 Act (改善) - Phase 5
└── Phase 5: 学習蓄積と継続改善

     ↓
🔄 次のPDCAサイクル開始
```

### 学習ループの保証

**従来の問題**:
```
Plan → Do → Do → Do... (学習断絶)
```

**改善された学習駆動開発**:
```
Plan → Do → Check → Act → 改善されたPlan
  ↑                         ↓
  ←←←← 継続的学習フィードバック ←←←←
```

### Kent Beck XP価値の実現

- **Communication**: 各Phaseでの内部対話・知識継承
- **Feedback**: Phase 3.6での強制フィードバック収集
- **Courage**: 各Phaseでの現実受容・変更勇気
- **Simplicity**: MVP検証による価値集中
- **Respect**: ユーザー価値・学習プロセスへの尊重

## 指示

以下の5つのPhaseを**順次実行**してください：

---

## 🔍 Phase 1: 要求の本質分析（Requirements Engineering）- PDCA「Plan」

### 1.1 5W1H + 制約分析

**ユーザーの真の目的と制約を分析**してください：

**Who（誰が）**:
- ユーザーの技術レベルを推定してください（初心者/中級者/上級者）
- 想定される使用環境を分析してください（個人/チーム/学習目的）

**What（何を）**:
- 表面的な要求文の背後にある真のニーズを特定してください
- 「本当に解決したい問題」を見つけてください

**When/Where（いつ・どこで）**:
- 使用タイミング（継続利用/一時利用/学習期間）
- 実行環境の制約（様々なマシン/特定環境/モバイル対応）

**Why（なぜ）**:
- この要求をする根本的な動機を推定してください
- 解決したい課題・得たい価値を特定してください

**How（どのように）**:
- ユーザーが理想とする体験・操作方法を想像してください

**制約分析**:
- 技術的制約（スキル、環境、リソース、権限）
- 時間的制約（開発時間、学習コスト、使用時間）  
- 配布制約（インストール、依存関係、アクセス性、共有方法）

### 1.2 Jobs-to-be-Done分析

**ユーザーが「雇いたい」ジョブを特定**してください：

**メインジョブ**:
- ユーザーが根本的に達成したいこと
- 解決したい本質的な課題

**関連ジョブ**:
- 付随的に解決したい課題
- 避けたい作業・トラブル

**感情的ジョブ**:
- 得たい感情（楽しさ、達成感、安心感）
- 避けたい感情（イライラ、不安、退屈）

**社会的ジョブ**:
- 他者との関係で得たい価値（共有、評価、貢献）

**競合分析**:
- 同じジョブを解決する他の手段との差別化ポイント

### 1.3 理想体験からの逆算設計

**摩擦ゼロの体験設計**:

1. **理想体験の定義**:
   - ユーザーが望む最終的な体験シナリオ
   - 「最高の場合、どうなるか？」

2. **摩擦ポイントの特定**:
   - 理想体験を阻む障害・面倒な作業
   - 「何が邪魔になるか？」

3. **技術選択の逆算**:
   - 摩擦を最小化する技術スタック選択
   - 「どうすれば摩擦を除去できるか？」

4. **MVP再定義**:
   - 理想体験の最小実現版
   - 「最小限で理想体験を実現するには？」

### 1.4 分析結果の統合と技術判定

**分析結果から技術スタックを決定**してください：

上記の分析結果を統合して、最適な技術選択を行ってください：

**体験重視型（摩擦ゼロ重視）**:
- ゼロインストール → 単体HTML/JSファイル
- 即座起動 → サーバーレス実行
- 環境非依存 → ブラウザ標準技術のみ
- 簡単共有 → ファイル一つで完結

**開発効率型（機能重視）**:
- 高機能 → モダンフレームワーク（React, Vue）
- 拡張性 → コンポーネント分割
- 保守性 → 開発サーバー + ビルドツール
- チーム開発 → TypeScript + 品質ツール

**学習・実験型（理解重視）**:
- 透明性 → シンプルな技術スタック（Vanilla JS）
- カスタマイズ性 → 設定可能な構造
- 段階的成長 → 拡張しやすい設計
- 理解促進 → 明確な分離とコメント

**重要な制約**:
- **JavaScriptプロジェクト**: bunまたはpnpmを使用してください。**npmは避けてください**。
- **体験重視**: 外部依存を最小化し、摩擦を除去してください。
- **学習重視**: 複雑すぎず、理解しやすい構造にしてください。

### 1.5 推奨フォルダ構造の提案

**分析結果に基づいて推奨フォルダ構造**を提示してください：

### 1.6 Kent Beck「勇気」の実践 - 現実受容と変更

**要求分析における勇気**:

```markdown
## 勇気を持った現実受容（必須）

### 技術選択変更の勇気
- [ ] 最初の技術選択が不適切と判明した場合の変更勇気
- [ ] 「既に始めたから」という沈没コスト錯誤の拒否
- [ ] ユーザー価値優先での技術妥協の拒否

### 要求見直しの勇気  
- [ ] 当初の要求理解が間違っていた場合の修正勇気
- [ ] 複雑すぎる要求の簡素化勇気
- [ ] 実現不可能な要求の現実的調整勇気

### 工数見積もりの正直さ
- [ ] 楽観的見積もりの現実的修正勇気
- [ ] 「短期間でできる」という期待への正直な対応
- [ ] 学習コスト・リスクの正直な評価

**Kent Beck**: "Courage without action is just anxiety"
```

**体験重視型（単体ファイル）**:
```
project/
├── src/
│   ├── game.html           # 最終成果物（全て内包）
│   ├── game.js             # 開発用JavaScript  
│   └── game.css            # 開発用CSS
├── tests/
│   └── game.test.js        # テストファイル
└── package.json            # テスト環境設定のみ
```

**開発効率型（フルスタック）**:
```
project/
├── src/
│   ├── components/         # UI コンポーネント
│   ├── utils/              # 共通ユーティリティ
│   ├── styles/             # スタイルファイル
│   └── main.js             # エントリーポイント
├── tests/
├── dist/                   # ビルド出力
└── vite.config.js          # 開発環境設定
```

**学習型（段階的成長）**:
```
project/
├── step1-basic/            # 基本機能
├── step2-enhanced/         # 機能拡張
├── step3-advanced/         # 高度な機能
├── tests/
└── README.md               # 学習ガイド
```

---

## 🛠️ Phase 2: 要求分析結果に基づく環境構築 - PDCA「Plan」

### 2.1 分析結果の確認と環境選択

**Phase 1の分析結果を使用**して適切な環境を構築してください：

**分析結果の確認**:
- **体験タイプ**: 体験重視 / 開発効率重視 / 学習重視
- **技術選択**: 単体ファイル / フルスタック / 段階的構造
- **制約条件**: インストール回避 / 拡張性重視 / 理解促進

### 2.2 体験タイプ別の環境構築

**体験重視型の環境構築**:
```bash
# シンプルなディレクトリ構造（外部依存最小）
mkdir -p src tests
# package.json（テスト環境のみ）
cat > package.json << 'EOF'
{
  "name": "standalone-app",
  "version": "1.0.0", 
  "type": "module",
  "scripts": {
    "test": "vitest run",
    "test:watch": "vitest"
  },
  "devDependencies": {
    "vitest": "^1.0.0",
    "jsdom": "^24.0.0"
  }
}
EOF
```

**開発効率型の環境構築**:
```bash
# フルスタック開発環境
mkdir -p src/{components,utils,styles} tests dist
# フレームワーク + 開発ツール環境
```

**学習型の環境構築**:
```bash
# 段階的学習構造
mkdir -p step{1..3}-{basic,enhanced,advanced} tests docs
# 学習ガイド付き環境
```

### 2.3 アジャイル管理ディレクトリの作成

**既存ユーザーのマイグレーション対応**:
```bash
# 既存の .claude/agile-artifacts/ がある場合は自動移行
if [ -d ".claude/agile-artifacts" ]; then
  echo "🔄 Migrating .claude/agile-artifacts → docs/agile-artifacts"
  mkdir -p docs/
  mv .claude/agile-artifacts docs/
  echo "✅ Migration completed"
fi
```

**新規ディレクトリ作成**:
```bash
mkdir -p docs/agile-artifacts/{stories,iterations,reviews,tdd-logs}
```

### 2.4 .gitignore の設定

個人用ログを除外し、チーム共有価値は含める：

```text
# TDD個人ログ（Git管理対象外）
docs/agile-artifacts/tdd-logs/

# 一般的な除外項目
node_modules/
__pycache__/
.env
.DS_Store
```

### 2.5 Git リポジトリの初期化（必要な場合）

```bash
git init
git add .gitignore
git commit -m "[INIT] TDD environment setup with agile structure"
```

### 2.6 基本テスト環境の確認

プロジェクトタイプに応じてテストコマンドを確認：

**JavaScript/TypeScript**:
```bash
# パッケージマネージャーの確認とテストスクリプト確認
if command -v bun &> /dev/null; then
  echo "推奨: bun を使用"
elif command -v pnpm &> /dev/null; then
  echo "推奨: pnpm を使用"
else
  echo "推奨: bun または pnpm のインストールを検討"
fi
```

**Python**:
```bash
# テストフレームワークの確認
python -c "import pytest" 2>/dev/null && echo "pytest 利用可能" || echo "pytest インストール推奨"
```

### 2.7 Kent Beck「勇気」の実践 - 環境決定

**環境構築における勇気**:

```markdown
## 技術的決定における勇気（必須）

### 既存環境への挑戦勇気
- [ ] より良い技術があるなら既存環境変更を恐れない
- [ ] 「慣れているから」という理由での妥協拒否
- [ ] チーム（将来の自分）の生産性向上のための変更勇気

### 複雑性排除の勇気
- [ ] 不要な依存関係の排除勇気
- [ ] 過剰な設定・ツールの簡素化勇気
- [ ] 「みんな使ってるから」という理由の疑問視

### 失敗への備えの勇気
- [ ] 実験的技術選択の失敗リスク受容
- [ ] バックアップ計画の事前準備
- [ ] 早期の方向転換を可能にする設計

**Kent Beck**: "The courage to change what isn't working"
```

---

## 📋 Phase 3: 要求分析結果に基づくストーリー作成 - PDCA「Plan」

### 3.1 Jobs-to-be-Done からストーリーへの変換

**Phase 1で特定したJobsをストーリーに変換**してください：

**メインジョブ → Story 1 (MVP Feature)**:
- **フィーチャー単位**: 2-4時間で完成可能な機能群
- ユーザーの根本的な目的を達成する最小機能セット
- Phase 1で特定した「理想体験」の最小実現版
- 例: 「基本ゲームプレイ機能」（ボード表示 + ピース操作 + 得点計算）

**関連ジョブ → Story 2-3 (Core Features)**:
- **フィーチャー単位**: 各2-4時間の統合機能
- 摩擦を除去し、体験を向上させる機能群
- ユーザーが避けたい作業・トラブルを解決するシステム
- 例: 「データ永続化システム」（保存 + 読込 + 自動保存）

**感情的・社会的ジョブ → Story 4+ (Enhancement Features)**:
- **フィーチャー単位**: 価値を高める機能セット
- 楽しさ、達成感、安心感を提供する統合機能
- 共有、評価、貢献の価値を実現する機能群
- 例: 「ソーシャル機能」（共有 + ランキング + マルチプレイ）

### 3.2 体験中心のMVPフィーチャー定義

**従来のシステム中心思考**:
❌ 「ゲームボードが表示される」（単一機能）

**フィーチャー中心思考**:
✅ 「基本的なゲームが一通り遊べる」（統合機能群）

**体験中心MVPフィーチャー定義の手順**:
1. **理想体験シナリオ**: Phase 1で定義した理想体験を使用
2. **摩擦ポイント除去**: 最大の障害となる摩擦を除去する機能群
3. **価値実現確認**: メインジョブが達成できる最小限の機能セット
4. **フィーチャー境界決定**: 「2-4時間で価値ある成果物」の境界線

**フィーチャー粒度の目安**:
- **小さすぎる❌**: 「ボタンを表示」（10分）
- **適切な粒度✅**: 「ユーザー認証システム」（2-3時間）
- **大きすぎる❌**: 「完全なECサイト」（数週間）

### 3.3 要求分析結果の統合

**Phase 1の分析結果を活用**してストーリーを具体化：

**5W1H分析結果の活用**:
- Who → ユーザータイプの明確化
- What → 機能要求の具体化  
- When/Where → 使用コンテキストの反映
- Why → 価値・理由の明確化
- How → 操作方法・体験の設計

**制約分析結果の反映**:
- 技術制約 → 実装可能性の考慮
- 時間制約 → 優先度・工数の調整
- 配布制約 → アクセス方法・共有方法の設計

### 3.3 受け入れ基準の定義

各ストーリーに具体的な**受け入れ基準 (Acceptance Criteria)**を定義：

```
GIVEN [前提条件]
WHEN [実行操作]  
THEN [期待結果]
```

### 3.4 ストーリーファイルの作成

`docs/agile-artifacts/stories/` ディレクトリに以下の形式でファイルを作成：

**ファイル名**: `user-stories-v1.0.md`

**テンプレート**:
```markdown
# ユーザーストーリー v1.0

**プロジェクト**: [要望名]
**作成日**: [今日の日付]
**技術スタック**: [選択した技術]
**イテレーション単位**: フィーチャー（2-4時間）

## Story 1: MVP Feature - [フィーチャー名]

**ストーリー**:
As a [ユーザー]
I want [統合機能群]
So that [価値ある体験]

**フィーチャー内容** (2-4時間で完成):
- [ ] [コア機能1] - 基本的な動作
- [ ] [コア機能2] - ユーザー操作
- [ ] [コア機能3] - フィードバック表示
- [ ] [統合テスト] - 一連の流れ確認

**受け入れ基準**:
- [ ] GIVEN 初期状態 WHEN 基本操作 THEN 期待する体験が得られる
- [ ] GIVEN エラー状態 WHEN リカバリ操作 THEN 正常に回復する
- [ ] [追加の統合基準...]

**優先度**: 🔥 CRITICAL (MVP)
**工数見積**: 2-3時間（機能開発 + 統合テスト）

## Story 2: Core Feature - [フィーチャー名]
[同様の形式...]

## Story 3: Core Feature - [フィーチャー名] 
[同様の形式...]

## フィーチャー分割の例

### 🎮 ゲーム開発の場合
- **Story 1**: 基本ゲームプレイ（ボード + ピース + 操作 + 得点）
- **Story 2**: ゲーム進行管理（開始 + 終了 + レベル + 状態保存）
- **Story 3**: ユーザー体験向上（効果音 + アニメーション + UI改善）

### 🌐 Web開発の場合
- **Story 1**: ユーザー認証システム（登録 + ログイン + セッション + 基本画面）
- **Story 2**: コンテンツ管理（CRUD + 検索 + ページング + 権限）
- **Story 3**: ユーザー間交流（コメント + いいね + 通知 + プロフィール）

### 📱 API開発の場合
- **Story 1**: リソース基本操作（エンドポイント + CRUD + バリデーション + エラー処理）
- **Story 2**: 認証・認可システム（トークン + ロール + アクセス制御 + ログ）
- **Story 3**: 高度な機能（検索 + フィルタ + ページネーション + キャッシュ）
```

---

## 🔍 Phase 3.5: MVP検証ゲート - 批判的レビュー - PDCA「Plan検証」

### 役割転換指示

**重要**: ここから視点を完全に切り替えてください。

あなたは今から **「悪魔の代弁者（Devil's Advocate）」** として、作成されたMVPストーリーを批判的に検証する外部コンサルタントです。

### 検証者ロールの設定

以下のロールからランダムに1つを選択し、その視点で厳格に検証してください：

**🎮 実際のユーザー視点**:
- 「これで本当に遊べる/使えるの？」
- 「期待してたのと違う！」
- 「5分で飽きない？」

**💰 投資家視点**:
- 「これで市場価値があるの？」
- 「競合に勝てる？」
- 「お金を出す価値ある？」

**🏆 競合開発者視点**:
- 「これなら簡単に勝てる」
- 「手抜きすぎ」
- 「基本機能が欠けてる」

**😈 意地悪なQA視点**:
- 「最悪のケースで破綻しない？」
- 「エッジケースは考慮済み？」
- 「ユーザビリティ最悪じゃない？」

### MVP製品完全性チェック

作成されたStory 1（MVPフィーチャー）に対して、以下を厳格にチェックしてください：

#### 1. 製品アイデンティティチェック

- [ ] これは単独で「[製品名]」と呼べるか？
- [ ] 競合製品の最小バージョンと比較して劣っていないか？
- [ ] ユーザーが期待する基本体験を満たしているか？

#### 2. ドメイン別必須要素チェック

**ゲーム開発の場合**:
- [ ] ゲームループが成立する（開始→プレイ→終了）
- [ ] 失敗のリスクがある（ゲームオーバー条件）
- [ ] プレイヤーの意思決定が結果に影響する
- [ ] 継続プレイのモチベーションがある

**Webアプリの場合**:
- [ ] ユーザーが目的を達成できる完全なフロー
- [ ] エラー時のリカバリー手段
- [ ] データの永続性（必要な場合）
- [ ] 基本的なユーザビリティ

**API/ツールの場合**:
- [ ] 実用的な問題を実際に解決できる
- [ ] エラーハンドリングが適切
- [ ] ドキュメント・使用例が十分
- [ ] セキュリティ基準を満たす

#### 3. 破壊的質問リスト

以下の**すべての質問**に**自信を持って「YES」**と答えられるまで、次のPhaseに進むことは**禁止**されています：

**汎用的価値検証質問**:
1. 「実際のユーザーが5分間使って、目的を達成できるか？」
2. 「友人に見せて、恥ずかしくない品質に達しているか？」
3. 「競合製品/既存手段と比較して、明確な優位性があるか？」
4. 「技術的都合でユーザー価値を犠牲にしていないか？」
5. 「これは『動く』だけでなく『使える』状態に達しているか？」

**ドメイン別具体的質問**:

**ゲーム開発の場合**:
- 「5分間楽しく遊び続けられるか？」

**Webアプリの場合**:
- 「ユーザーが想定した作業を最後まで完了できるか？」

**API開発の場合**:
- 「実際の業務問題を解決できるか？」

**CLI/ツール開発の場合**:
- 「手作業より明らかに効率的か？」

### 検証結果の判定

#### PASS条件

- 全てのチェック項目がクリア
- 破壊的質問に自信を持って「YES」
- 検証者ロールから見ても許容できる品質

#### FAIL条件の処理

**FAIL判定の場合、以下の形式で報告**:

```
🚨 MVP検証失敗

検証者: [選択したロール]
判定理由: [具体的な問題点]

欠落している必須要素:
1. [具体的な機能名]: [なぜ必須かの理由]
2. [具体的な機能名]: [なぜ必須かの理由]
3. [具体的な機能名]: [なぜ必須かの理由]

修正案:
- Story 1に追加すべき機能: [具体的な提案]
- 実装順序の変更提案: [具体的な提案]
- 受け入れ基準の修正: [具体的な提案]

修正後、再度この検証を実行することを強く推奨します。
```

### 自己検証トリガー

Story 1作成完了後、必ず以下を自問してください：

1. **製品性チェック**: 「もし私がユーザーなら、これで満足するか？」
2. **価値優先チェック**: 「技術的都合で、価値を犠牲にしていないか？」
3. **完全性チェック**: 「『動く』と『使える』を混同していないか？」
4. **競合比較チェック**: 「既存の類似製品と比べて劣っていないか？」

**もし少しでも疑問があれば、このPhase 3.5を必ず実行してください。**

### 検証通過の確認（強制実行）

**⚠️ 重要**: このPhase 3.5は**必須プロセス**です。検証を回避することはできません。

#### ✅ PASS判定の場合

**のみ**Phase 4への進行が許可されます。

#### ❌ FAIL判定の場合

**Phase 4への進行は絶対に禁止**されています。以下を実行してください：

1. **即座に実装を停止**
2. **Phase 3に戻ってStory 1を根本的に見直し**
3. **欠落している必須要素を追加**
4. **受け入れ基準を現実的に修正**
5. **再度Phase 3.5を実行**

**注意**: FAIL状態での作業継続は、時間とリソースの無駄遣いです。勇気を持って計画を修正してください。

### 検証実行の強制

この検証は**スキップ・延期・省略することができません**：
- 「時間がないから後で」→ **禁止**
- 「だいたい動くから大丈夫」→ **禁止**  
- 「完璧じゃないけど進める」→ **禁止**

**Kent Beck**: "勇気を持って現実を受け入れ、必要な変更を恐れるな"

---

## 📝 Phase 3.6: 強制フィードバック収集 - 学習ループの実現 - PDCA「Check」

### PDCAサイクルの「Check」フェーズ

**重要**: このPhaseは**Phase 4完了後に必ず実行**されます。

Phase 4（実装）で得られた学習を確実に蓄積し、次のイテレーションに活かすための**必須プロセス**です。

### フィードバック収集の強制実行

**実行タイミング**:
- 各機能実装完了時（Phase 4の各フェーズ完了後）
- 重要な発見・課題が発生した時
- Phase全体完了時
- 設計変更が必要になった時

### 4軸フィードバック収集（必須）

#### 1. 実装フィードバック

```markdown
### 実装フィードバック記録

**想定より難しかった部分**:
- [ ] [具体的な機能名]: [難易度の理由と解決策]
- [ ] [技術的課題]: [遭遇した問題と対応方法]

**想定より簡単だった部分**:
- [ ] [具体的な機能名]: [簡単だった理由]
- [ ] [効率化ポイント]: [次回活用できる技術・手法]

**新たに発見した技術的制約**:
- [ ] [制約名]: [内容と対応策]
- [ ] [パフォーマンス課題]: [測定結果と改善案]

**設計変更が必要になった部分**:
- [ ] [変更箇所]: [理由と新しい設計]
- [ ] [アーキテクチャ見直し]: [変更内容と影響範囲]
```

#### 2. ユーザビリティフィードバック

```markdown
### ユーザビリティフィードバック記録

**実際に使ってみての感想**:
- [ ] [良かった点]: [具体的な体験]
- [ ] [改善が必要な点]: [具体的な問題と解決案]

**操作で困惑した部分**:
- [ ] [UI/UX課題]: [問題の詳細と改善案]
- [ ] [直感性の課題]: [ユーザーの期待との乖離]

**期待と異なった動作**:
- [ ] [機能名]: [期待した動作 vs 実際の動作]
- [ ] [修正の必要性]: [優先度と対応方針]
```

#### 3. 価値フィードバック

```markdown
### 価値フィードバック記録

**想定した価値の実現度**:
- [ ] [価値1]: [実現度 1-5点] [理由]
- [ ] [価値2]: [実現度 1-5点] [理由]

**新たに発見された価値**:
- [ ] [予期しない価値]: [具体的な内容]
- [ ] [追加可能な価値]: [実装コストと効果]

**価値の優先度変化**:
- [ ] [上がった価値]: [理由]
- [ ] [下がった価値]: [理由]

**ユーザーの反応（想像/実際）**:
- [ ] [ポジティブな反応]: [具体的な場面]
- [ ] [改善要求]: [具体的な要望]
```

#### 4. 工数フィードバック

```markdown
### 工数フィードバック記録

**見積もりと実績の比較**:
- 見積もり: [X時間] → 実績: [Y時間]
- 差異の理由: [具体的な要因]

**時間がかかった理由**:
- [ ] [学習コスト]: [新技術・概念の理解時間]
- [ ] [デバッグ]: [予期しない問題の解決時間]
- [ ] [設計見直し]: [アーキテクチャ変更の時間]

**効率化できそうな部分**:
- [ ] [改善ポイント]: [具体的な改善方法]
- [ ] [ツール・手法]: [次回使用したい技術]

**次回の見積もり精度向上のための学習**:
- [ ] [見積もりミスの要因]: [改善方法]
- [ ] [隠れた複雑性]: [見落とした要素]
```

### フィードバック蓄積システム

**蓄積場所**: `docs/agile-artifacts/reviews/feedback-[日付].md`

**蓄積内容**:
1. **技術的学習**: API使い方、最適化手法、互換性対応
2. **ドメイン的学習**: 業務知識、ユーザー行動、UX改善
3. **プロセス的学習**: 見積もり改善、TDD最適化、チーム連携

### 継続的ストーリー更新（必須）

**フィードバックに基づく即座更新**:

```markdown
## user-stories更新プロセス

### 更新タイミング
- 各機能実装完了後
- 重要な発見があった時
- 設計変更が発生した時

### 更新内容
1. **実装状況の正確な反映**
   - チェックボックスの現実的な更新
   - 進捗率の正確な表示

2. **発見した課題の追記**
   - 技術的制約の明記
   - ユーザビリティ課題の記録

3. **受け入れ基準の現実的調整**
   - 実装可能性に基づく修正
   - ユーザー価値の再定義

4. **優先度の動的見直し**
   - 実装経験に基づく重要度変更
   - 次のイテレーションの方向性調整
```

### Kent Beck「勇気」の実践

**計画変更の勇気**:
- [ ] 当初計画が不適切と判明した場合の修正勇気
- [ ] ストーリーを根本的に書き直す勇気
- [ ] 優先度を大幅に見直す勇気
- [ ] 技術選択を変更する勇気

**現実受容の勇気**:
- [ ] 想定より困難だった現実の受容
- [ ] 工数見積もりの甘さの認識
- [ ] ユーザビリティ課題の正直な評価

### フィードバック未実行の禁止

**以下は絶対に禁止**:
- 「後でまとめて振り返る」→ **禁止**（学習が薄れる）
- 「うまくいったから記録不要」→ **禁止**（成功要因を見逃す）
- 「時間がないから省略」→ **禁止**（最も重要な学習機会）

**Kent Beck**: "Feedback is the lifeblood of software development"

---

## 📅 Phase 4: イテレーション計画・実装 - PDCA「Do」

### 4.1 フィーチャー単位イテレーション計画（学習統合型）

**2-4時間のフィーチャー完成イテレーション**で実装計画を作成：

1. **統合された価値ある機能群**を2-4時間で完成
2. **複数のRed-Green-Refactorサイクル**で段階的に構築
3. **統合テストと実使用確認**まで含めて完了
4. **各Phase完了時の必須フィードバック収集**（Phase 3.6実行）
5. **継続的ストーリー更新**による計画の現実化

### 学習ループ統合の実装プロセス

**各Phase完了時の必須作業**:

```markdown
## Phase完了チェックリスト（必須）

### 技術実装の完了
- [ ] 該当機能が動作する
- [ ] テストが通る
- [ ] コードレビューが完了

### フィードバック収集の完了（Phase 3.6）
- [ ] 実装フィードバックを記録
- [ ] ユーザビリティフィードバックを記録
- [ ] 価値フィードバックを記録
- [ ] 工数フィードバックを記録

### ストーリー更新の完了
- [ ] user-storiesの進捗を現実的に更新
- [ ] 発見した課題を追記
- [ ] 受け入れ基準を実態に合わせて調整
- [ ] 次の優先度を見直し

### 計画修正の勇気
- [ ] 当初計画の問題点を正直に評価
- [ ] 必要に応じて残りの実装計画を修正
- [ ] 工数見積もりを現実的に再調整
```

### 4.2 実装順序の決定

**MVPフィーチャーファースト原則**で実装順序を決定：

**Iteration 1 (2-3時間)**: Story 1のMVPフィーチャー実装（学習統合型）

**Phase 1 (30分)**: コア機能1のTDD実装
- 失敗するテスト作成 → Fake It実装 → リファクタリング
- **Phase完了時**: Phase 3.6フィードバック収集 (5分)
- **ストーリー更新**: 実装状況の反映 (5分)

**Phase 2 (30分)**: コア機能2のTDD実装  
- テスト追加 → Triangulation実装 → 統合
- **Phase完了時**: Phase 3.6フィードバック収集 (5分)
- **ストーリー更新**: 発見した課題の追記 (5分)

**Phase 3 (30分)**: コア機能3のTDD実装
- テスト追加 → 実装 → 全体調整  
- **Phase完了時**: Phase 3.6フィードバック収集 (5分)
- **計画見直し**: 残り時間と優先度の再評価 (5分)

**Phase 4 (30分)**: 統合テストと動作確認
- End-to-Endテスト → 実使用確認 → ドキュメント更新
- **価値検証**: 実際にユーザーとして5分間使用 (10分)
- **Phase 3.5再実行**: MVP検証ゲートによる最終確認 (10分)

**Phase 5 (30-60分)**: ポリッシュとデプロイ準備
- UI/UX改善 → エラー処理強化 → 配布準備
- **最終フィードバック**: 全体的な学習の蓄積 (15分)
- **次期計画**: 学習に基づく次のイテレーション調整 (15分)

### 4.3 Kent Beck三大戦略の適用計画

各Task実装時の戦略を事前に計画：

**Fake It戦略** (60%以上で使用):
- 実装方法が不明確
- 複雑なビジネスロジック
- まずはハードコーディングで動かす

**Triangulation戦略**:
- 2つ目のテストで一般化
- パターンが見えてきた時

**Obvious Implementation戦略**:
- 数学的に自明な処理のみ
- 1行で完結する簡単な処理

### 4.4 技術的制約・リスクの洗い出し

**技術リスク**:
- 未経験の技術スタック
- パフォーマンス要件
- 外部API依存

**対応策**:
- スパイクソリューション（調査用実装）
- 代替手段の準備
- 段階的複雑化

### 4.5 イテレーション計画ファイルの作成

`docs/agile-artifacts/iterations/` ディレクトリに以下を作成：

**ファイル名**: `iteration-plan-v1.0.md`

**テンプレート**:
```markdown
# イテレーション計画 v1.0

**プロジェクト**: [要望名]
**計画日**: [今日の日付]
**イテレーション期間**: 2-4時間（フィーチャー単位）

## Iteration 1: MVPフィーチャー実装

**目標**: Story 1の統合機能群を完成させる
**フィーチャー**: [例: ユーザー認証システム]

### Phase 1: コア機能1実装 (30分)
**機能**: [例: ユーザー登録]
- [ ] 失敗するテスト作成 (5分)
- [ ] Fake It実装で動作確認 (15分)
- [ ] 基本リファクタリング (10分)
- [ ] コミット: [BEHAVIOR] Add user registration

### Phase 2: コア機能2実装 (30分)
**機能**: [例: ログイン処理]
- [ ] テスト追加 (5分)
- [ ] Triangulation実装 (15分)
- [ ] 機能1との統合 (10分)
- [ ] コミット: [BEHAVIOR] Add login functionality

### Phase 3: コア機能3実装 (30分)
**機能**: [例: セッション管理]
- [ ] テスト追加 (5分)
- [ ] 実装と調整 (15分)
- [ ] 全体統合 (10分)
- [ ] コミット: [BEHAVIOR] Add session management

### Phase 4: 統合テストと動作確認 (30分)
- [ ] End-to-Endシナリオテスト (10分)
- [ ] 実際のユーザーフロー確認 (10分)
- [ ] ドキュメント更新 (10分)
- [ ] コミット: [BEHAVIOR] Complete authentication feature

### Phase 5: ポリッシュと配布準備 (30-60分)
- [ ] UI/UX改善 (15分)
- [ ] エラー処理・エッジケース対応 (15分)
- [ ] パフォーマンス確認 (15分)
- [ ] 配布形式の準備 (15分)
- [ ] コミット: [STRUCTURE] Polish authentication system

**成功基準**:
- [ ] フィーチャー全体が動作する
- [ ] ユーザーが一連の操作を完了できる
- [ ] 価値ある成果物として配布可能
- [ ] 次のフィーチャーとの統合準備完了

**次のイテレーション候補**:
- Story 2: [次のフィーチャー名]
- Story 1の拡張機能
```

---

## 📈 Phase 5: 学習蓄積と継続改善 - PDCA「Act」

### PDCAサイクルの完成

このPhaseは、Phase 1-4で得られた**すべての学習を蓄積**し、**次のイテレーションに活かす**ための**Act（改善）フェーズ**です。

### 5.1 全体的学習の統合と評価

**Phase 1-4で蓄積された学習の統合**:

```markdown
## 学習統合レポート作成（必須）

### 技術的学習の評価
**最も重要な技術的発見**:
- [ ] 想定外の技術的制約とその解決策
- [ ] 効果的だった技術・手法・ツール
- [ ] 避けるべき技術的な落とし穴
- [ ] パフォーマンス・互換性の知見

**実装効率の分析**:
- [ ] 時間がかかった作業とその理由
- [ ] 効率的に進んだ作業とその要因
- [ ] デバッグ・トラブルシューティングの学習
- [ ] コード品質向上のポイント

### ユーザー価値の評価
**価値実現の成功・失敗分析**:
- [ ] 想定した価値の実現度（1-5点評価）
- [ ] ユーザー体験の満足度評価
- [ ] 競合・既存手段との優位性評価
- [ ] 改善すべきユーザビリティ課題

**MVP定義の精度評価**:
- [ ] 最初のMVP定義は適切だったか？
- [ ] 実装してみて分かった真の必須機能
- [ ] 過剰だった機能・不足していた機能
- [ ] 次回のMVP定義改善ポイント

### プロセス改善の評価
**TDDプロセスの効果測定**:
- [ ] Red-Green-Refactorサイクルの効果
- [ ] Kent Beck戦略（Fake It/Triangulation/Obvious）の適用効果
- [ ] テストファースト開発の困難点と解決策
- [ ] リファクタリングのタイミングと効果

**フィードバックループの効果測定**:
- [ ] Phase 3.5 MVP検証ゲートの有効性
- [ ] Phase 3.6 フィードバック収集の効果
- [ ] 継続的ストーリー更新の価値
- [ ] 計画修正の勇気の実践度
```

### 5.2 次期イテレーション計画の最適化

**学習に基づく計画改善**:

```markdown
## 次期イテレーション最適化（必須）

### 工数見積もりの精度向上
**見積もり精度の分析**:
- 予想工数: [X時間] → 実績工数: [Y時間]
- 差異要因: [具体的な理由]
- 改善策: [次回の見積もり方法]

**隠れた複雑性の特定**:
- [ ] 見落としていた依存関係
- [ ] 想定外の学習コスト
- [ ] 統合時の調整コスト
- [ ] テスト・デバッグコスト

### 優先度の再評価
**価値の優先順位見直し**:
- [ ] 実装してみて価値が高かった機能
- [ ] 実装してみて価値が低かった機能
- [ ] ユーザーが本当に求めている機能
- [ ] 技術的負債となりそうな機能

**リスクの再評価**:
- [ ] 技術的リスクの見直し
- [ ] 工数リスクの見直し
- [ ] ユーザビリティリスクの見直し
- [ ] 統合リスクの見直し
```

### 5.3 知識資産の永続化

**組織学習の蓄積**:

```markdown
## 知識資産化（必須）

### ドキュメント更新
**user-stories の最終更新**:
- [ ] 実装結果に基づく最終状態の記録
- [ ] 発見した課題の完全な記録
- [ ] 次期イテレーションへの引き継ぎ事項
- [ ] 成功・失敗要因の分析結果

**技術ドキュメントの作成**:
- [ ] アーキテクチャ決定記録（ADR）
- [ ] API仕様・使用方法
- [ ] セットアップ・デプロイ手順
- [ ] トラブルシューティングガイド

### 学習ライブラリの構築
**再利用可能な知識の抽出**:
- [ ] 汎用的な技術パターン
- [ ] ドメイン固有の知見
- [ ] 効果的な開発プロセス
- [ ] 避けるべき落とし穴集
```

### 5.4 継続的改善の文化構築

**Kent Beck XP価値の実践評価**:

```markdown
## XP価値の実践度評価

### Communication（コミュニケーション）
- [ ] 内部対話（計画者↔実装者）の効果
- [ ] ドキュメントによる知識伝達の精度
- [ ] 将来の自分への情報継承の品質

### Feedback（フィードバック）
- [ ] 継続的フィードバック収集の効果
- [ ] ユーザー視点での価値評価の精度
- [ ] 技術的フィードバックの活用度

### Courage（勇気）
- [ ] 計画変更への勇気の実践度
- [ ] 現実受容の勇気の発揮度
- [ ] 品質基準の妥協拒否の勇気

### Simplicity（シンプリシティ）
- [ ] 必要最小限の実装への集中度
- [ ] 過剰設計の回避度
- [ ] ユーザー価値への集中度

### Respect（尊重）
- [ ] ユーザーニーズへの尊重度
- [ ] 自分の学習・成長への尊重度
- [ ] プロセス・原則への尊重度
```

### 5.5 成功指標の達成評価と次期目標設定

**最終成果の客観的評価**:

```markdown
## 成功指標達成度評価

### MVP成功指標の達成度
- [ ] ユーザーが5分間価値を感じて使用できる
- [ ] 友人に見せて恥ずかしくない品質
- [ ] 競合・既存手段との明確な差別化
- [ ] 技術的都合での価値犠牲なし

### プロセス成功指標の達成度
- [ ] 計画通りの工数での完成
- [ ] 品質ゲートのクリア
- [ ] 継続的学習の実践
- [ ] チーム（将来の自分）への知識継承

### 次期イテレーション目標の設定
**学習に基づく現実的目標**:
- [ ] 次の価値実現目標
- [ ] 改善された工数見積もり
- [ ] 強化すべきスキル・知識領域
- [ ] プロセス改善の具体的施策
```

### 5.6 完了宣言と次期開始準備

```text
🎉 学習駆動開発イテレーション完了！

📊 学習成果:
├── docs/agile-artifacts/
│   ├── stories/user-stories-v[X.Y].md     # 最新ユーザーストーリー
│   ├── iterations/iteration-plan-v[X.Y].md # 改善イテレーション計画
│   ├── reviews/feedback-[日付].md         # 学習フィードバック
│   └── knowledge/lessons-learned-[日付].md # 知識資産

🎯 達成成果:
- **MVP価値実現**: [具体的な成果]
- **技術学習**: [重要な技術的発見]
- **プロセス改善**: [改善されたプロセス]
- **次期準備**: [次のイテレーション最適化]

🚀 次期イテレーション準備完了

蓄積された学習に基づき、より効果的な次のイテレーションを開始します。

## 次期イテレーション開始コマンド

学習に基づいて最適化された次の開発フェーズ：

```bash
/tdd:run [次の優先機能]
```

**Kent Beck**: "Software development is a learning game"
```