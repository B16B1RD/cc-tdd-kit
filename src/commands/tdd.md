---
description: "統合TDD開発 - init, story, planを1コマンドで完全実行"
argument-hint: "作りたいものを説明してください（例: テトリスゲーム、REST APIサーバー）"
allowed-tools: ["Write", "Read", "LS", "WebSearch", "Bash", "TodoWrite"]
---

# 統合TDD開発

要望: $ARGUMENTS

## 🎯 統合開発フロー

この統合コマンドは以下の機能を順次実行します：
1. **要望分析・技術選択**
2. **環境初期化** (従来の`/tdd:init`機能)
3. **ユーザーストーリー作成** (従来の`/tdd:story`機能)  
4. **イテレーション計画** (従来の`/tdd:plan`機能)
5. **実装開始案内**

## 指示

以下の5つのPhaseを**順次実行**してください：

---

## 🔍 Phase 1: 要求の本質分析（Requirements Engineering）

### 1.1 5W1H + 制約分析

**ユーザーの真の目的と制約を分析**してください：

**Who（誰が）**:
- ユーザーの技術レベルを推定してください（初心者/中級者/上級者）
- 想定される使用環境を分析してください（個人/チーム/学習目的）

**What（何を）**:
- 表面的な要求文の背後にある真のニーズを特定してください
- 「本当に解決したい問題」を見つけてください

**When/Where（いつ・どこで）**:
- 使用タイミング（継続利用/一時利用/学習期間）
- 実行環境の制約（様々なマシン/特定環境/モバイル対応）

**Why（なぜ）**:
- この要求をする根本的な動機を推定してください
- 解決したい課題・得たい価値を特定してください

**How（どのように）**:
- ユーザーが理想とする体験・操作方法を想像してください

**制約分析**:
- 技術的制約（スキル、環境、リソース、権限）
- 時間的制約（開発時間、学習コスト、使用時間）  
- 配布制約（インストール、依存関係、アクセス性、共有方法）

### 1.2 Jobs-to-be-Done分析

**ユーザーが「雇いたい」ジョブを特定**してください：

**メインジョブ**:
- ユーザーが根本的に達成したいこと
- 解決したい本質的な課題

**関連ジョブ**:
- 付随的に解決したい課題
- 避けたい作業・トラブル

**感情的ジョブ**:
- 得たい感情（楽しさ、達成感、安心感）
- 避けたい感情（イライラ、不安、退屈）

**社会的ジョブ**:
- 他者との関係で得たい価値（共有、評価、貢献）

**競合分析**:
- 同じジョブを解決する他の手段との差別化ポイント

### 1.3 理想体験からの逆算設計

**摩擦ゼロの体験設計**:

1. **理想体験の定義**:
   - ユーザーが望む最終的な体験シナリオ
   - 「最高の場合、どうなるか？」

2. **摩擦ポイントの特定**:
   - 理想体験を阻む障害・面倒な作業
   - 「何が邪魔になるか？」

3. **技術選択の逆算**:
   - 摩擦を最小化する技術スタック選択
   - 「どうすれば摩擦を除去できるか？」

4. **MVP再定義**:
   - 理想体験の最小実現版
   - 「最小限で理想体験を実現するには？」

### 1.4 分析結果の統合と技術判定

**分析結果から技術スタックを決定**してください：

上記の分析結果を統合して、最適な技術選択を行ってください：

**体験重視型（摩擦ゼロ重視）**:
- ゼロインストール → 単体HTML/JSファイル
- 即座起動 → サーバーレス実行
- 環境非依存 → ブラウザ標準技術のみ
- 簡単共有 → ファイル一つで完結

**開発効率型（機能重視）**:
- 高機能 → モダンフレームワーク（React, Vue）
- 拡張性 → コンポーネント分割
- 保守性 → 開発サーバー + ビルドツール
- チーム開発 → TypeScript + 品質ツール

**学習・実験型（理解重視）**:
- 透明性 → シンプルな技術スタック（Vanilla JS）
- カスタマイズ性 → 設定可能な構造
- 段階的成長 → 拡張しやすい設計
- 理解促進 → 明確な分離とコメント

**重要な制約**:
- **JavaScriptプロジェクト**: bunまたはpnpmを使用してください。**npmは避けてください**。
- **体験重視**: 外部依存を最小化し、摩擦を除去してください。
- **学習重視**: 複雑すぎず、理解しやすい構造にしてください。

### 1.5 推奨フォルダ構造の提案

**分析結果に基づいて推奨フォルダ構造**を提示してください：

**体験重視型（単体ファイル）**:
```
project/
├── src/
│   ├── game.html           # 最終成果物（全て内包）
│   ├── game.js             # 開発用JavaScript  
│   └── game.css            # 開発用CSS
├── tests/
│   └── game.test.js        # テストファイル
└── package.json            # テスト環境設定のみ
```

**開発効率型（フルスタック）**:
```
project/
├── src/
│   ├── components/         # UI コンポーネント
│   ├── utils/              # 共通ユーティリティ
│   ├── styles/             # スタイルファイル
│   └── main.js             # エントリーポイント
├── tests/
├── dist/                   # ビルド出力
└── vite.config.js          # 開発環境設定
```

**学習型（段階的成長）**:
```
project/
├── step1-basic/            # 基本機能
├── step2-enhanced/         # 機能拡張
├── step3-advanced/         # 高度な機能
├── tests/
└── README.md               # 学習ガイド
```

---

## 🛠️ Phase 2: 要求分析結果に基づく環境構築

### 2.1 分析結果の確認と環境選択

**Phase 1の分析結果を使用**して適切な環境を構築してください：

**分析結果の確認**:
- **体験タイプ**: 体験重視 / 開発効率重視 / 学習重視
- **技術選択**: 単体ファイル / フルスタック / 段階的構造
- **制約条件**: インストール回避 / 拡張性重視 / 理解促進

### 2.2 体験タイプ別の環境構築

**体験重視型の環境構築**:
```bash
# シンプルなディレクトリ構造（外部依存最小）
mkdir -p src tests
# package.json（テスト環境のみ）
cat > package.json << 'EOF'
{
  "name": "standalone-app",
  "version": "1.0.0", 
  "type": "module",
  "scripts": {
    "test": "vitest run",
    "test:watch": "vitest"
  },
  "devDependencies": {
    "vitest": "^1.0.0",
    "jsdom": "^24.0.0"
  }
}
EOF
```

**開発効率型の環境構築**:
```bash
# フルスタック開発環境
mkdir -p src/{components,utils,styles} tests dist
# フレームワーク + 開発ツール環境
```

**学習型の環境構築**:
```bash
# 段階的学習構造
mkdir -p step{1..3}-{basic,enhanced,advanced} tests docs
# 学習ガイド付き環境
```

### 2.3 アジャイル管理ディレクトリの作成

```bash
mkdir -p .claude/agile-artifacts/{stories,iterations,reviews,tdd-logs}
```

### 2.3 .gitignore の設定

個人用ログを除外し、チーム共有価値は含める：

```text
# TDD個人ログ（Git管理対象外）
.claude/agile-artifacts/tdd-logs/

# 一般的な除外項目
node_modules/
__pycache__/
.env
.DS_Store
```

### 2.4 Git リポジトリの初期化（必要な場合）

```bash
git init
git add .gitignore
git commit -m "[INIT] TDD environment setup with agile structure"
```

### 2.5 基本テスト環境の確認

プロジェクトタイプに応じてテストコマンドを確認：

**JavaScript/TypeScript**:
```bash
# パッケージマネージャーの確認とテストスクリプト確認
if command -v bun &> /dev/null; then
  echo "推奨: bun を使用"
elif command -v pnpm &> /dev/null; then
  echo "推奨: pnpm を使用"
else
  echo "推奨: bun または pnpm のインストールを検討"
fi
```

**Python**:
```bash
# テストフレームワークの確認
python -c "import pytest" 2>/dev/null && echo "pytest 利用可能" || echo "pytest インストール推奨"
```

---

## 📋 Phase 3: 要求分析結果に基づくストーリー作成

### 3.1 Jobs-to-be-Done からストーリーへの変換

**Phase 1で特定したJobsをストーリーに変換**してください：

**メインジョブ → Story 1 (MVP Feature)**:
- **フィーチャー単位**: 2-4時間で完成可能な機能群
- ユーザーの根本的な目的を達成する最小機能セット
- Phase 1で特定した「理想体験」の最小実現版
- 例: 「基本ゲームプレイ機能」（ボード表示 + ピース操作 + 得点計算）

**関連ジョブ → Story 2-3 (Core Features)**:
- **フィーチャー単位**: 各2-4時間の統合機能
- 摩擦を除去し、体験を向上させる機能群
- ユーザーが避けたい作業・トラブルを解決するシステム
- 例: 「データ永続化システム」（保存 + 読込 + 自動保存）

**感情的・社会的ジョブ → Story 4+ (Enhancement Features)**:
- **フィーチャー単位**: 価値を高める機能セット
- 楽しさ、達成感、安心感を提供する統合機能
- 共有、評価、貢献の価値を実現する機能群
- 例: 「ソーシャル機能」（共有 + ランキング + マルチプレイ）

### 3.2 体験中心のMVPフィーチャー定義

**従来のシステム中心思考**:
❌ 「ゲームボードが表示される」（単一機能）

**フィーチャー中心思考**:
✅ 「基本的なゲームが一通り遊べる」（統合機能群）

**体験中心MVPフィーチャー定義の手順**:
1. **理想体験シナリオ**: Phase 1で定義した理想体験を使用
2. **摩擦ポイント除去**: 最大の障害となる摩擦を除去する機能群
3. **価値実現確認**: メインジョブが達成できる最小限の機能セット
4. **フィーチャー境界決定**: 「2-4時間で価値ある成果物」の境界線

**フィーチャー粒度の目安**:
- **小さすぎる❌**: 「ボタンを表示」（10分）
- **適切な粒度✅**: 「ユーザー認証システム」（2-3時間）
- **大きすぎる❌**: 「完全なECサイト」（数週間）

### 3.3 要求分析結果の統合

**Phase 1の分析結果を活用**してストーリーを具体化：

**5W1H分析結果の活用**:
- Who → ユーザータイプの明確化
- What → 機能要求の具体化  
- When/Where → 使用コンテキストの反映
- Why → 価値・理由の明確化
- How → 操作方法・体験の設計

**制約分析結果の反映**:
- 技術制約 → 実装可能性の考慮
- 時間制約 → 優先度・工数の調整
- 配布制約 → アクセス方法・共有方法の設計

### 3.3 受け入れ基準の定義

各ストーリーに具体的な**受け入れ基準 (Acceptance Criteria)**を定義：

```
GIVEN [前提条件]
WHEN [実行操作]  
THEN [期待結果]
```

### 3.4 ストーリーファイルの作成

`.claude/agile-artifacts/stories/` ディレクトリに以下の形式でファイルを作成：

**ファイル名**: `user-stories-v1.0.md`

**テンプレート**:
```markdown
# ユーザーストーリー v1.0

**プロジェクト**: [要望名]
**作成日**: [今日の日付]
**技術スタック**: [選択した技術]
**イテレーション単位**: フィーチャー（2-4時間）

## Story 1: MVP Feature - [フィーチャー名]

**ストーリー**:
As a [ユーザー]
I want [統合機能群]
So that [価値ある体験]

**フィーチャー内容** (2-4時間で完成):
- [ ] [コア機能1] - 基本的な動作
- [ ] [コア機能2] - ユーザー操作
- [ ] [コア機能3] - フィードバック表示
- [ ] [統合テスト] - 一連の流れ確認

**受け入れ基準**:
- [ ] GIVEN 初期状態 WHEN 基本操作 THEN 期待する体験が得られる
- [ ] GIVEN エラー状態 WHEN リカバリ操作 THEN 正常に回復する
- [ ] [追加の統合基準...]

**優先度**: 🔥 CRITICAL (MVP)
**工数見積**: 2-3時間（機能開発 + 統合テスト）

## Story 2: Core Feature - [フィーチャー名]
[同様の形式...]

## Story 3: Core Feature - [フィーチャー名] 
[同様の形式...]

## フィーチャー分割の例

### 🎮 ゲーム開発の場合
- **Story 1**: 基本ゲームプレイ（ボード + ピース + 操作 + 得点）
- **Story 2**: ゲーム進行管理（開始 + 終了 + レベル + 状態保存）
- **Story 3**: ユーザー体験向上（効果音 + アニメーション + UI改善）

### 🌐 Web開発の場合
- **Story 1**: ユーザー認証システム（登録 + ログイン + セッション + 基本画面）
- **Story 2**: コンテンツ管理（CRUD + 検索 + ページング + 権限）
- **Story 3**: ユーザー間交流（コメント + いいね + 通知 + プロフィール）

### 📱 API開発の場合
- **Story 1**: リソース基本操作（エンドポイント + CRUD + バリデーション + エラー処理）
- **Story 2**: 認証・認可システム（トークン + ロール + アクセス制御 + ログ）
- **Story 3**: 高度な機能（検索 + フィルタ + ページネーション + キャッシュ）
```

---

## 📅 Phase 4: イテレーション計画 (plan統合)

### 4.1 フィーチャー単位イテレーション計画

**2-4時間のフィーチャー完成イテレーション**で実装計画を作成：

1. **統合された価値ある機能群**を2-4時間で完成
2. **複数のRed-Green-Refactorサイクル**で段階的に構築
3. **統合テストと実使用確認**まで含めて完了

### 4.2 実装順序の決定

**MVPフィーチャーファースト原則**で実装順序を決定：

**Iteration 1 (2-3時間)**: Story 1のMVPフィーチャー実装
- Phase 1 (30分): コア機能1のTDD実装
  - 失敗するテスト作成 → Fake It実装 → リファクタリング
- Phase 2 (30分): コア機能2のTDD実装
  - テスト追加 → Triangulation実装 → 統合
- Phase 3 (30分): コア機能3のTDD実装
  - テスト追加 → 実装 → 全体調整
- Phase 4 (30分): 統合テストと動作確認
  - End-to-Endテスト → 実使用確認 → ドキュメント更新
- Phase 5 (30-60分): ポリッシュとデプロイ準備
  - UI/UX改善 → エラー処理強化 → 配布準備

### 4.3 Kent Beck三大戦略の適用計画

各Task実装時の戦略を事前に計画：

**Fake It戦略** (60%以上で使用):
- 実装方法が不明確
- 複雑なビジネスロジック
- まずはハードコーディングで動かす

**Triangulation戦略**:
- 2つ目のテストで一般化
- パターンが見えてきた時

**Obvious Implementation戦略**:
- 数学的に自明な処理のみ
- 1行で完結する簡単な処理

### 4.4 技術的制約・リスクの洗い出し

**技術リスク**:
- 未経験の技術スタック
- パフォーマンス要件
- 外部API依存

**対応策**:
- スパイクソリューション（調査用実装）
- 代替手段の準備
- 段階的複雑化

### 4.5 イテレーション計画ファイルの作成

`.claude/agile-artifacts/iterations/` ディレクトリに以下を作成：

**ファイル名**: `iteration-plan-v1.0.md`

**テンプレート**:
```markdown
# イテレーション計画 v1.0

**プロジェクト**: [要望名]
**計画日**: [今日の日付]
**イテレーション期間**: 2-4時間（フィーチャー単位）

## Iteration 1: MVPフィーチャー実装

**目標**: Story 1の統合機能群を完成させる
**フィーチャー**: [例: ユーザー認証システム]

### Phase 1: コア機能1実装 (30分)
**機能**: [例: ユーザー登録]
- [ ] 失敗するテスト作成 (5分)
- [ ] Fake It実装で動作確認 (15分)
- [ ] 基本リファクタリング (10分)
- [ ] コミット: [BEHAVIOR] Add user registration

### Phase 2: コア機能2実装 (30分)
**機能**: [例: ログイン処理]
- [ ] テスト追加 (5分)
- [ ] Triangulation実装 (15分)
- [ ] 機能1との統合 (10分)
- [ ] コミット: [BEHAVIOR] Add login functionality

### Phase 3: コア機能3実装 (30分)
**機能**: [例: セッション管理]
- [ ] テスト追加 (5分)
- [ ] 実装と調整 (15分)
- [ ] 全体統合 (10分)
- [ ] コミット: [BEHAVIOR] Add session management

### Phase 4: 統合テストと動作確認 (30分)
- [ ] End-to-Endシナリオテスト (10分)
- [ ] 実際のユーザーフロー確認 (10分)
- [ ] ドキュメント更新 (10分)
- [ ] コミット: [BEHAVIOR] Complete authentication feature

### Phase 5: ポリッシュと配布準備 (30-60分)
- [ ] UI/UX改善 (15分)
- [ ] エラー処理・エッジケース対応 (15分)
- [ ] パフォーマンス確認 (15分)
- [ ] 配布形式の準備 (15分)
- [ ] コミット: [STRUCTURE] Polish authentication system

**成功基準**:
- [ ] フィーチャー全体が動作する
- [ ] ユーザーが一連の操作を完了できる
- [ ] 価値ある成果物として配布可能
- [ ] 次のフィーチャーとの統合準備完了

**次のイテレーション候補**:
- Story 2: [次のフィーチャー名]
- Story 1の拡張機能
```

---

## 🚀 Phase 5: 実装開始案内

### 5.1 開発環境の最終確認

**実装開始前チェックリスト**:
- [ ] Git リポジトリが初期化されている
- [ ] テスト環境が構築されている  
- [ ] フィーチャー単位のユーザーストーリーが作成されている
- [ ] 2-4時間のフィーチャー完成計画が準備されている
- [ ] 実装戦略が決定されている

### 5.2 TDD開始コマンドの案内

**フィーチャー単位のKent Beck純正TDD**で実装を開始してください：

```bash
# フィーチャー実装開始（自動判定）
/tdd:run

# フィーチャー実装開始（番号指定）
/tdd:run 1  # 不安度ランキング1位のフィーチャー

# フィーチャー実装開始（ストーリー指定）
/tdd:run 1.1  # Story 1.1のフィーチャー

# 例（フィーチャー名を直接指定）:
/tdd:run authentication-system  # ユーザー認証システム全体
/tdd:run game-core-mechanics   # ゲーム基本メカニクス
/tdd:run api-resource-crud     # APIリソース基本操作
```

### 5.3 品質ゲート設定の確認

各実装後に必ず以下を実行：

```bash
# テスト実行
[パッケージマネージャー] test -- --watchAll=false --forceExit

# 品質チェック  
[パッケージマネージャー] run lint
[パッケージマネージャー] run typecheck  # TypeScriptの場合

# 動作確認
[パッケージマネージャー] run dev
```

### 5.4 継続的フィードバックループの設定

**各機能完成後の確認手順**:

1. **動作デモ**: 実際にユーザーが使える状態か？
2. **価値確認**: ユーザーにとって価値があるか？
3. **次の優先度**: 次に重要な機能は何か？
4. **改善点**: 現在の実装で改善すべき点は？

### 5.5 完了メッセージの表示

```text
🎉 統合TDD開発環境の構築完了！

📋 作成された成果物:
├── .claude/agile-artifacts/
│   ├── stories/user-stories-v1.0.md     # ユーザーストーリー
│   ├── iterations/iteration-plan-v1.0.md # イテレーション計画
│   └── [その他のディレクトリ]

🎯 プロジェクト概要:
- **要望**: $ARGUMENTS
- **技術スタック**: [選択した技術]
- **MVPフィーチャー**: [Story 1の統合機能群]
- **初回イテレーション**: 2-4時間でフィーチャー完成

🚀 実装開始準備完了:

**🎯 今すぐ実行推奨**:
```bash
/tdd:run
```
↑ Kent Beck純正TDDで最優先フィーチャーの実装開始（自動判定）

**⚡ その他の実装開始オプション**:
```bash
/tdd:run 1                    # 不安度1位のフィーチャー
/tdd:run 1.1                  # Story 1.1を直接指定
/tdd:run authentication       # 特定フィーチャー名で指定
```

**📊 進捗確認・品質管理**:
```bash
/tdd:status                   # プロジェクト全体状況
/tdd:review                   # 品質レビュー・フィードバック
```

**💡 実装のコツ**:
- Red → Green → Refactor サイクルを厳守
- Fake It戦略でハードコードから開始
- 2-4時間でフィーチャー完成を目指す
- 各Phase完了時にテスト実行・動作確認

**🔥 成功パターン**:
1. `/tdd:run` でTDD開始 → 最優先フィーチャーを自動選択
2. Red-Green-Refactor を1つずつ実行 → 小さく確実に進歩  
3. 2-4時間でフィーチャー完成 → 価値ある成果物を配布可能状態に
4. `/tdd:status` で進捗確認 → 次のフィーチャーを計画

**⚠️ よくある迷いポイントの解決**:
- 「何から始めるか分からない」→ `/tdd:run` で自動判定に任せる
- 「テストが難しい」→ Fake It戦略でハードコードから開始
- 「設計が複雑」→ 2-4時間で完成する小さなフィーチャーに集中
- 「品質が心配」→ `/tdd:review` で継続的フィードバック取得

🎉 **準備完了！今すぐ `/tdd:run` を実行してTDD実装を開始してください！**

---

**🚀 次のアクション（クリックするだけ）**:

1️⃣ **今すぐ実装開始** → `/tdd:run`
2️⃣ **進捗確認** → `/tdd:status`  
3️⃣ **品質チェック** → `/tdd:review`

**💪 成功への最短パス**: `/tdd:run` → 2-4時間集中 → 価値あるMVP完成！

## 完了条件

**Phase 1**:
- ✅ 要望分析完了・技術スタック決定
- ✅ 推奨フォルダ構造提示

**Phase 2**:
- ✅ .claude/agile-artifacts/ 構造が作成されている
- ✅ .gitignore が適切に設定されている  
- ✅ Git リポジトリが初期化されている（必要な場合）
- ✅ テスト環境の状態が確認されている

**Phase 3**:
- ✅ MVPファーストのユーザーストーリーが作成されている
- ✅ 受け入れ基準が具体的に定義されている
- ✅ stories/ ディレクトリにファイルが保存されている

**Phase 4**:
- ✅ 90分イテレーション計画が作成されている
- ✅ Kent Beck戦略の適用計画が完成している
- ✅ iterations/ ディレクトリにファイルが保存されている

**Phase 5**:
- ✅ 実装開始コマンドが明確に案内されている
- ✅ 品質ゲートが設定されている
- ✅ 継続的フィードバックループが確立されている

## エラーハンドリング

**Phase 1 失敗**: 要望不明確・技術スタック判定不可
→ 詳細な要望確認を依頼

**Phase 2 失敗**: Git初期化失敗・既存プロジェクト衝突  
→ 既存状況確認・競合解決案提示

**Phase 3 失敗**: ユーザーストーリー作成失敗・入力値不正
→ ストーリー形式の再説明・要望の再整理

**Phase 4 失敗**: イテレーション計画作成失敗・工数見積もり異常
→ より小さな単位での計画作成・リスク要因の特定

**Phase 5 失敗**: 最終案内表示失敗
→ 前段階の結果確認・部分的成功要素の保護